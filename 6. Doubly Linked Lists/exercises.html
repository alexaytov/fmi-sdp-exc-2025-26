<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8" />
  <title>Упражнения: Списъци, Итератори и Управление на Паметта</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="exercises-styles.css" />
</head>
<body>
<header class="header">
  <h1>Упражнения: C++ Списъци, Итератори и Управление на Паметта</h1>
  <p>Маркирай завършените задачи. Прогресът се пази локално. Клавишна комбинация <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>C</kbd> изчиства всички отметки.</p>
  <div class="progress-wrapper">
    <div class="progress-bar" id="progress-bar"></div>
  </div>
  <div class="stats" id="stats"></div>
</header>
<main class="container" id="exercise-container">
  <section class="level-group">
    <h2>Лесни Упражнения (Основни Концепции)</h2>
    <div class="exercises-list">
      
      <!-- Exercise 1 -->
      <div class="exercise-card" data-difficulty="easy">
        <div class="exercise-header">
          <div class="exercise-title-group">
            <input type="checkbox" id="ex1" class="exercise-checkbox">
            <label for="ex1" class="exercise-number">Упражнение 1</label>
          </div>
          <div class="exercise-actions">
            <span class="difficulty-badge easy">ЛЕСНО</span>
            <button class="show-answer-btn" data-answer="answer1">Покажи отговор</button>
          </div>
        </div>
        <div class="exercise-content">
          <div class="question">
            Какви са основните разлики между еднопосочен списък (singly linked list) и двусвързан списък (doubly linked list)?
          </div>
          <div class="answer" id="answer1">
            <strong>Отговор:</strong>
            <ul>
              <li><strong>Еднопосочен списък:</strong> Всеки възел има само един указател <code>next</code> към следващия елемент. Може да се обхожда само в една посока (напред).</li>
              <li><strong>Двусвързан списък:</strong> Всеки възел има два указателя - <code>prev</code> към предишния и <code>next</code> към следващия елемент. Може да се обхожда в двете посоки.</li>
              <li><strong>Памет:</strong> Двусвързаният списък заема повече памет заради допълнителния указател.</li>
              <li><strong>Операции:</strong> Двусвързаният списък позволява по-ефективно изтриване на елемент при известен указател.</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- Exercise 2 -->
      <div class="exercise-card" data-difficulty="easy">
        <div class="exercise-header">
          <div class="exercise-title-group">
            <input type="checkbox" id="ex2" class="exercise-checkbox">
            <label for="ex2" class="exercise-number">Упражнение 2</label>
          </div>
          <div class="exercise-actions">
            <span class="difficulty-badge easy">ЛЕСНО</span>
            <button class="show-answer-btn" data-answer="answer2">Покажи отговор</button>
          </div>
        </div>
        <div class="exercise-content">
          <div class="question">
            В C++, кои оператори се използват за заделяне и освобождаване на динамична памет?<br>
            a) <code>malloc</code> и <code>free</code><br>
            b) <code>new</code> и <code>delete</code><br>
            c) <code>alloc</code> и <code>dealloc</code><br>
            d) <code>create</code> и <code>destroy</code>
          </div>
          <div class="answer" id="answer2">
            <strong>Отговор:</strong> b) <code>new</code> и <code>delete</code>
            <p>В C++ използваме <code>new</code> за заделяне на динамична памет и <code>delete</code> за освобождаването ѝ. За масиви използваме <code>new[]</code> и <code>delete[]</code>.</p>
          </div>
        </div>
      </div>

      <!-- Exercise 3 -->
      <div class="exercise-card" data-difficulty="easy">
        <div class="exercise-header">
          <div class="exercise-title-group">
            <input type="checkbox" id="ex3" class="exercise-checkbox">
            <label for="ex3" class="exercise-number">Упражнение 3</label>
          </div>
          <div class="exercise-actions">
            <span class="difficulty-badge easy">ЛЕСНО</span>
            <button class="show-answer-btn" data-answer="answer3">Покажи отговор</button>
          </div>
        </div>
        <div class="exercise-content">
          <div class="question">
            Какво е изтичане на памет (memory leak)? Опишете с едно изречение.
          </div>
          <div class="answer" id="answer3">
            <strong>Отговор:</strong> Изтичане на памет е ситуация, при която програмата заделя динамична памет, но не я освобождава след използването ѝ, което води до натрупване на неизползвана памет.
          </div>
        </div>
      </div>

      <!-- Exercise 4 -->
      <div class="exercise-card" data-difficulty="easy">
        <div class="exercise-header">
          <div class="exercise-title-group">
            <input type="checkbox" id="ex4" class="exercise-checkbox">
            <label for="ex4" class="exercise-number">Упражнение 4</label>
          </div>
          <div class="exercise-actions">
            <span class="difficulty-badge easy">ЛЕСНО</span>
            <button class="show-answer-btn" data-answer="answer4">Покажи отговор</button>
          </div>
        </div>
        <div class="exercise-content">
          <div class="question">
            Какво съдържа всеки възел в двусвързан списък?
          </div>
          <div class="answer" id="answer4">
            <strong>Отговор:</strong> Всеки възел съдържа:
            <ul>
              <li><strong>Данни</strong> (стойността, която се съхранява)</li>
              <li><strong>Указател <code>prev</code></strong> към предишния възел</li>
              <li><strong>Указател <code>next</code></strong> към следващия възел</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- Exercise 5 -->
      <div class="exercise-card" data-difficulty="easy">
        <div class="exercise-header">
          <div class="exercise-title-group">
            <input type="checkbox" id="ex5" class="exercise-checkbox">
            <label for="ex5" class="exercise-number">Упражнение 5</label>
          </div>
          <div class="exercise-actions">
            <span class="difficulty-badge easy">ЛЕСНО</span>
            <button class="show-answer-btn" data-answer="answer5">Покажи отговор</button>
          </div>
        </div>
        <div class="exercise-content">
          <div class="question">
            Какво винаги трябва да правите след извикване на <code>delete</code> на указател като добра практика?
            <pre><code>int* ptr = new int(10);
delete ptr;
// Какво трябва да следва?</code></pre>
          </div>
          <div class="answer" id="answer5">
            <strong>Отговор:</strong>
            <pre><code>ptr = nullptr;</code></pre>
            <p>След <code>delete</code> винаги задавайте указателя на <code>nullptr</code>. Това предотвратява използването на "висящ" указател (dangling pointer) и прави грешките по-лесни за откриване.</p>
          </div>
        </div>
      </div>

      <!-- Exercise 6 -->
      <div class="exercise-card" data-difficulty="easy">
        <div class="exercise-header">
          <div class="exercise-title-group">
            <input type="checkbox" id="ex6" class="exercise-checkbox">
            <label for="ex6" class="exercise-number">Упражнение 6</label>
          </div>
          <div class="exercise-actions">
            <span class="difficulty-badge easy">ЛЕСНО</span>
            <button class="show-answer-btn" data-answer="answer6">Покажи отговор</button>
          </div>
        </div>
        <div class="exercise-content">
          <div class="question">
            Каква е времевата сложност O() за добавяне на елемент в края на двусвързан списък, когато имате указател към tail?
          </div>
          <div class="answer" id="answer6">
            <strong>Отговор:</strong> <code>O(1)</code> - константно време.
            <p>Когато имаме указател към <code>tail</code>, можем директно да добавим новия елемент и да актуализираме само няколко указателя, независимо от размера на списъка.</p>
          </div>
        </div>
      </div>

      <!-- Exercise 7 -->
      <div class="exercise-card" data-difficulty="easy">
        <div class="exercise-header">
          <div class="exercise-title-group">
            <input type="checkbox" id="ex7" class="exercise-checkbox">
            <label for="ex7" class="exercise-number">Упражнение 7</label>
          </div>
          <div class="exercise-actions">
            <span class="difficulty-badge easy">ЛЕСНО</span>
            <button class="show-answer-btn" data-answer="answer7">Покажи отговор</button>
          </div>
        </div>
        <div class="exercise-content">
          <div class="question">
            Кое от следните ще причини изтичане на памет?
            <pre><code>// Опция A:
int* ptr = new int(5);
delete ptr;

// Опция B:
int* ptr = new int(5);
ptr = new int(10);
delete ptr;

// Опция C:
int* ptr = new int(5);
ptr = nullptr;</code></pre>
          </div>
          <div class="answer" id="answer7">
            <strong>Отговор:</strong> Опция B и Опция C причиняват изтичане на памет.
            <ul>
              <li><strong>Опция A:</strong> Правилна - паметта се освобождава.</li>
              <li><strong>Опция B:</strong> Грешна - първата заделена памет (5) изтича, защото указателят се презаписва преди да бъде освободена.</li>
              <li><strong>Опция C:</strong> Грешна - заделената памет изтича, защото губим указателя без да освободим паметта.</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- Exercise 8 -->
      <div class="exercise-card" data-difficulty="easy">
        <div class="exercise-header">
          <div class="exercise-title-group">
            <input type="checkbox" id="ex8" class="exercise-checkbox">
            <label for="ex8" class="exercise-number">Упражнение 8</label>
          </div>
          <div class="exercise-actions">
            <span class="difficulty-badge easy">ЛЕСНО</span>
            <button class="show-answer-btn" data-answer="answer8">Покажи отговор</button>
          </div>
        </div>
        <div class="exercise-content">
          <div class="question">
            Каква е основната роля на итератор в C++?
          </div>
          <div class="answer" id="answer8">
            <strong>Отговор:</strong> Итераторът предоставя унифициран начин за обхождане на елементите на различни контейнери, скривайки детайлите на вътрешната им структура. Това позволява писането на общ код, който работи с масиви, списъци, вектори и др., без да се налага промяна при смяна на типа контейнер.
          </div>
        </div>
      </div>

    </div>
  </section>

  <section class="level-group">
    <h2>Средни Упражнения</h2>
    <div class="exercises-list">
      
      <!-- Exercise 9 -->
      <div class="exercise-card" data-difficulty="medium">
        <div class="exercise-header">
          <div class="exercise-title-group">
            <input type="checkbox" id="ex9" class="exercise-checkbox">
            <label for="ex9" class="exercise-number">Упражнение 9</label>
          </div>
          <div class="exercise-actions">
            <span class="difficulty-badge medium">СРЕДНО</span>
            <button class="show-answer-btn" data-answer="answer9">Покажи отговор</button>
          </div>
        </div>
        <div class="exercise-content">
          <div class="question">
            Допълнете следния код за правилно освобождаване на масив:
            <pre><code>int* arr = new int[10];
// Използвайте масива...
// Напишете правилния код за освобождаване тук:</code></pre>
          </div>
          <div class="answer" id="answer9">
            <strong>Отговор:</strong>
            <pre><code>delete[] arr;
arr = nullptr;</code></pre>
            <p>Важно е да използвате <code>delete[]</code> (не просто <code>delete</code>) за масиви, защото той освобождава цялата заделена памет за всички елементи.</p>
          </div>
        </div>
      </div>

      <!-- Exercise 10 -->
      <div class="exercise-card" data-difficulty="medium">
        <div class="exercise-header">
          <div class="exercise-title-group">
            <input type="checkbox" id="ex10" class="exercise-checkbox">
            <label for="ex10" class="exercise-number">Упражнение 10</label>
          </div>
          <div class="exercise-actions">
            <span class="difficulty-badge medium">СРЕДНО</span>
            <button class="show-answer-btn" data-answer="answer10">Покажи отговор</button>
          </div>
        </div>
        <div class="exercise-content">
          <div class="question">
            Какво ще се случи в следния код?
            <pre><code>struct Node {
    int data;
    Node* next;
    Node* prev;
};

Node* n = new Node();
n->data = 42;
// Програмата приключва без delete</code></pre>
          </div>
          <div class="answer" id="answer10">
            <strong>Отговор:</strong> Ще има <strong>изтичане на памет</strong>. Заделената памет за възела не се освобождава преди приключване на програмата. Правилният код трябва да включва:
            <pre><code>delete n;
n = nullptr;</code></pre>
          </div>
        </div>
      </div>

      <!-- Exercise 11 -->
      <div class="exercise-card" data-difficulty="medium">
        <div class="exercise-header">
          <div class="exercise-title-group">
            <input type="checkbox" id="ex11" class="exercise-checkbox">
            <label for="ex11" class="exercise-number">Упражнение 11</label>
          </div>
          <div class="exercise-actions">
            <span class="difficulty-badge medium">СРЕДНО</span>
            <button class="show-answer-btn" data-answer="answer11">Покажи отговор</button>
          </div>
        </div>
        <div class="exercise-content">
          <div class="question">
            Намерете грешката в тази функция за премахване на възел от двусвързан списък:
            <pre><code>void removeNode(Node* node) {
    node->prev->next = node->next;
    node->next->prev = node->prev;
    // Какво липсва?
}</code></pre>
          </div>
          <div class="answer" id="answer11">
            <strong>Отговор:</strong> Липсва <code>delete node;</code>
            <p>След актуализиране на указателите, трябва да освободим паметта за премахнатия възел:</p>
            <pre><code>void removeNode(Node* node) {
    node->prev->next = node->next;
    node->next->prev = node->prev;
    delete node; // Освобождаване на паметта
}</code></pre>
            <p><strong>Допълнително:</strong> Функцията не проверява дали <code>prev</code> или <code>next</code> са <code>nullptr</code>, което може да доведе до грешка при премахване на първия или последния елемент.</p>
          </div>
        </div>
      </div>

      <!-- Exercise 12 -->
      <div class="exercise-card" data-difficulty="medium">
        <div class="exercise-header">
          <div class="exercise-title-group">
            <input type="checkbox" id="ex12" class="exercise-checkbox">
            <label for="ex12" class="exercise-number">Упражнение 12</label>
          </div>
          <div class="exercise-actions">
            <span class="difficulty-badge medium">СРЕДНО</span>
            <button class="show-answer-btn" data-answer="answer12">Покажи отговор</button>
          </div>
        </div>
        <div class="exercise-content">
          <div class="question">
            Имплементирайте метод за добавяне на елемент в началото на двусвързан списък:
            <pre><code>class DoublyLinkedList {
private:
    Node* head;
    Node* tail;
public:
    void addFront(int value) {
        // Вашата имплементация тук
    }
};</code></pre>
          </div>
          <div class="answer" id="answer12">
            <strong>Отговор:</strong>
            <pre><code>void addFront(int value) {
    Node* newNode = new Node(value);
    
    if (head) { // Ако списъкът не е празен
        newNode->next = head;
        head->prev = newNode;
        head = newNode;
    } else { // Ако списъкът е празен
        head = newNode;
        tail = newNode;
    }
}</code></pre>
          </div>
        </div>
      </div>

      <!-- Exercise 13 -->
      <div class="exercise-card" data-difficulty="medium">
        <div class="exercise-header">
          <div class="exercise-title-group">
            <input type="checkbox" id="ex13" class="exercise-checkbox">
            <label for="ex13" class="exercise-number">Упражнение 13</label>
          </div>
          <div class="exercise-actions">
            <span class="difficulty-badge medium">СРЕДНО</span>
            <button class="show-answer-btn" data-answer="answer13">Покажи отговор</button>
          </div>
        </div>
        <div class="exercise-content">
          <div class="question">
            Какво е RAII и как помага за предотвратяване на изтичане на памет? Дайте пример.
          </div>
          <div class="answer" id="answer13">
            <strong>Отговор:</strong> <strong>RAII (Resource Acquisition Is Initialization)</strong> е идиом в C++, при който ресурсите (като памет) се придобиват в конструктора на обекта и автоматично се освобождават в деструктора му.
            <p><strong>Пример:</strong></p>
            <pre><code>class SafeArray {
private:
    int* data;
    size_t size;
public:
    SafeArray(size_t n) : size(n) {
        data = new int[n]; // Заделяне в конструктора
    }
    
    ~SafeArray() {
        delete[] data; // Автоматично освобождаване в деструктора
    }
    // ... други методи ...
};</code></pre>
            <p>Когато <code>SafeArray</code> излезе от обхват, деструкторът автоматично освобождава паметта.</p>
          </div>
        </div>
      </div>

      <!-- Exercise 14 -->
      <div class="exercise-card" data-difficulty="medium">
        <div class="exercise-header">
          <div class="exercise-title-group">
            <input type="checkbox" id="ex14" class="exercise-checkbox">
            <label for="ex14" class="exercise-number">Упражнение 14</label>
          </div>
          <div class="exercise-actions">
            <span class="difficulty-badge medium">СРЕДНО</span>
            <button class="show-answer-btn" data-answer="answer14">Покажи отговор</button>
          </div>
        </div>
        <div class="exercise-content">
          <div class="question">
            Допълнете класа итератор за прост масив:
            <pre><code>template&lt;typename T&gt;
class ArrayIterator {
private:
    T* current;
public:
    ArrayIterator(T* ptr) : current(ptr) {}
    
    T& operator*() const {
        // Вашият код тук
    }
    
    ArrayIterator& operator++() {
        // Вашият код тук
    }
    
    bool operator!=(const ArrayIterator& other) const {
        // Вашият код тук
    }
};</code></pre>
          </div>
          <div class="answer" id="answer14">
            <strong>Отговор:</strong>
            <pre><code>T& operator*() const {
    return *current; // Връща референция към текущия елемент
}

ArrayIterator& operator++() {
    ++current; // Премества указателя напред
    return *this;
}

bool operator!=(const ArrayIterator& other) const {
    return current != other.current; // Сравнява указателите
}</code></pre>
          </div>
        </div>
      </div>

      <!-- Exercise 15 -->
      <div class="exercise-card" data-difficulty="medium">
        <div class="exercise-header">
          <div class="exercise-title-group">
            <input type="checkbox" id="ex15" class="exercise-checkbox">
            <label for="ex15" class="exercise-number">Упражнение 15</label>
          </div>
          <div class="exercise-actions">
            <span class="difficulty-badge medium">СРЕДНО</span>
            <button class="show-answer-btn" data-answer="answer15">Покажи отговор</button>
          </div>
        </div>
        <div class="exercise-content">
          <div class="question">
            Обяснете защо този код има изтичане на памет и го поправете:
            <pre><code>void processData() {
    int* data = new int[100];
    for (int i = 0; i &lt; 100; i++) {
        data[i] = i * 2;
    }
    if (data[50] > 100) {
        return; // Ранно връщане
    }
    delete[] data;
}</code></pre>
          </div>
          <div class="answer" id="answer15">
            <strong>Проблем:</strong> При ранно връщане (<code>return</code>), <code>delete[] data</code> никога не се изпълнява, което води до изтичане на памет.
            <p><strong>Решение 1 - добавяне на delete преди return:</strong></p>
            <pre><code>void processData() {
    int* data = new int[100];
    for (int i = 0; i &lt; 100; i++) {
        data[i] = i * 2;
    }
    if (data[50] > 100) {
        delete[] data; // Освобождаване преди връщане
        return;
    }
    delete[] data;
}</code></pre>
            <p><strong>Решение 2 - използване на RAII (по-добро):</strong></p>
            <pre><code>void processData() {
    std::unique_ptr&lt;int[]&gt; data = std::make_unique&lt;int[]&gt;(100);
    for (int i = 0; i &lt; 100; i++) {
        data[i] = i * 2;
    }
    if (data[50] > 100) {
        return; // Паметта се освобождава автоматично
    }
    // Паметта се освобождава автоматично и тук
}</code></pre>
          </div>
        </div>
      </div>

      <!-- Exercise 16 -->
      <div class="exercise-card" data-difficulty="medium">
        <div class="exercise-header">
          <div class="exercise-title-group">
            <input type="checkbox" id="ex16" class="exercise-checkbox">
            <label for="ex16" class="exercise-number">Упражнение 16</label>
          </div>
          <div class="exercise-actions">
            <span class="difficulty-badge medium">СРЕДНО</span>
            <button class="show-answer-btn" data-answer="answer16">Покажи отговор</button>
          </div>
        </div>
        <div class="exercise-content">
          <div class="question">
            Какви са трите основни типа smart pointers в C++ и кога бихте използвали всеки?
          </div>
          <div class="answer" id="answer16">
            <strong>Отговор:</strong>
            <ul>
              <li><strong><code>std::unique_ptr</code>:</strong> Ексклузивна собственост. Използвайте когато само един обект трябва да притежава ресурса. Не може да се копира, само да се премести с <code>std::move</code>.</li>
              <li><strong><code>std::shared_ptr</code>:</strong> Споделена собственост чрез reference counting. Използвайте когато множество обекти трябва да споделят ресурса. Паметта се освобождава, когато последният <code>shared_ptr</code> бъде унищожен.</li>
              <li><strong><code>std::weak_ptr</code>:</strong> "Слаба" референция към <code>shared_ptr</code>, която не увеличава reference count. Използвайте за прекъсване на циклични зависимости между <code>shared_ptr</code> обекти.</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- Exercise 17 -->
      <div class="exercise-card" data-difficulty="medium">
        <div class="exercise-header">
          <div class="exercise-title-group">
            <input type="checkbox" id="ex17" class="exercise-checkbox">
            <label for="ex17" class="exercise-number">Упражнение 17</label>
          </div>
          <div class="exercise-actions">
            <span class="difficulty-badge medium">СРЕДНО</span>
            <button class="show-answer-btn" data-answer="answer17">Покажи отговор</button>
          </div>
        </div>
        <div class="exercise-content">
          <div class="question">
            Имплементирайте функция за броене на елементите в двусвързан списък:
            <pre><code>int countElements(Node* head) {
    // Вашата имплементация тук
}</code></pre>
          </div>
          <div class="answer" id="answer17">
            <strong>Отговор:</strong>
            <pre><code>int countElements(Node* head) {
    int count = 0;
    Node* current = head;
    
    while (current != nullptr) {
        count++;
        current = current->next;
    }
    
    return count;
}</code></pre>
            <p>Времева сложност: <code>O(n)</code>, където n е броят елементи в списъка.</p>
          </div>
        </div>
      </div>

      <!-- Exercise 18 -->
      <div class="exercise-card" data-difficulty="medium">
        <div class="exercise-header">
          <div class="exercise-title-group">
            <input type="checkbox" id="ex18" class="exercise-checkbox">
            <label for="ex18" class="exercise-number">Упражнение 18</label>
          </div>
          <div class="exercise-actions">
            <span class="difficulty-badge medium">СРЕДНО</span>
            <button class="show-answer-btn" data-answer="answer18">Покажи отговор</button>
          </div>
        </div>
        <div class="exercise-content">
          <div class="question">
            Напишете деструктор за двусвързан списък, който правилно освобождава всички възли:
            <pre><code>class DoublyLinkedList {
private:
    Node* head;
    Node* tail;
public:
    ~DoublyLinkedList() {
        // Вашата имплементация тук
    }
};</code></pre>
          </div>
          <div class="answer" id="answer18">
            <strong>Отговор:</strong>
            <pre><code>~DoublyLinkedList() {
    Node* current = head;
    while (current != nullptr) {
        Node* next_node = current->next;
        delete current;
        current = next_node;
    }
    head = nullptr;
    tail = nullptr;
}</code></pre>
            <p>Обхождаме целия списък и изтриваме всеки възел. Важно е да запазим <code>next</code> указателя преди да изтрием текущия възел.</p>
          </div>
        </div>
      </div>

    </div>
  </section>

  <section class="level-group">
    <h2>Трудни Упражнения</h2>
    <div class="exercises-list">
      
      <!-- Exercise 19 -->
      <div class="exercise-card" data-difficulty="hard">
        <div class="exercise-header">
          <div class="exercise-title-group">
            <input type="checkbox" id="ex19" class="exercise-checkbox">
            <label for="ex19" class="exercise-number">Упражнение 19</label>
          </div>
          <div class="exercise-actions">
            <span class="difficulty-badge hard">ТРУДНО</span>
            <button class="show-answer-btn" data-answer="answer19">Покажи отговор</button>
          </div>
        </div>
        <div class="exercise-content">
          <div class="question">
            Имплементирайте метод <code>insert</code>, който добавя нов елемент след дадена итераторна позиция:
            <pre><code>template&lt;typename T&gt;
class DoublyLinkedList {
public:
    class Iterator {
        Node* current;
        // ... iterator methods ...
    };
    
    void insertAfter(Iterator position, T value) {
        // Вашата имплементация тук
    }
};</code></pre>
          </div>
          <div class="answer" id="answer19">
            <strong>Отговор:</strong>
            <pre><code>void insertAfter(Iterator position, T value) {
    if (!position.current) return; // Проверка за валидност
    
    Node* newNode = new Node(value);
    Node* next = position.current->next;
    
    // Свързване на новия възел
    newNode->prev = position.current;
    newNode->next = next;
    
    // Актуализиране на съседните възли
    position.current->next = newNode;
    
    if (next) {
        next->prev = newNode;
    } else {
        // Ако вмъкваме след последния елемент
        tail = newNode;
    }
}</code></pre>
            <p><strong>Забележка:</strong> Необходим е достъп до <code>current</code> от итератора, което изисква или <code>friend</code> декларация, или публичен getter.</p>
          </div>
        </div>
      </div>

      <!-- Exercise 20 -->
      <div class="exercise-card" data-difficulty="hard">
        <div class="exercise-header">
          <div class="exercise-title-group">
            <input type="checkbox" id="ex20" class="exercise-checkbox">
            <label for="ex20" class="exercise-number">Упражнение 20</label>
          </div>
          <div class="exercise-actions">
            <span class="difficulty-badge hard">ТРУДНО</span>
            <button class="show-answer-btn" data-answer="answer20">Покажи отговор</button>
          </div>
        </div>
        <div class="exercise-content">
          <div class="question">
            Анализирайте следния код и идентифицирайте всички проблеми, свързани с паметта:
            <pre><code>class DataManager {
    int* buffer;
    int size;
public:
    DataManager(int n) {
        size = n;
        buffer = new int[size];
    }
    
    void resize(int newSize) {
        buffer = new int[newSize];
        size = newSize;
    }
    
    DataManager(const DataManager& other) {
        size = other.size;
        buffer = other.buffer;
    }
};</code></pre>
          </div>
          <div class="answer" id="answer20">
            <strong>Проблеми:</strong>
            <ul>
              <li><strong>1. Липсва деструктор:</strong> Няма <code>~DataManager()</code> за освобождаване на <code>buffer</code>.</li>
              <li><strong>2. Memory leak в <code>resize()</code>:</strong> Старата памет не се освобождава преди заделянето на нова.</li>
              <li><strong>3. Shallow copy в copy constructor:</strong> <code>buffer = other.buffer</code> просто копира указателя, не прави deep copy на данните.</li>
              <li><strong>4. Липсва copy assignment operator:</strong> Няма <code>operator=</code> за правилно копиране.</li>
              <li><strong>5. Липсва move constructor и move assignment:</strong> За ефективно преместване на ресурси.</li>
            </ul>
            <p><strong>Правилна имплементация:</strong></p>
            <pre><code>class DataManager {
    int* buffer;
    int size;
public:
    DataManager(int n) : size(n), buffer(new int[n]) {}
    
    ~DataManager() { delete[] buffer; }
    
    void resize(int newSize) {
        int* newBuffer = new int[newSize];
        int copySize = std::min(size, newSize);
        for (int i = 0; i &lt; copySize; i++) {
            newBuffer[i] = buffer[i];
        }
        delete[] buffer;
        buffer = newBuffer;
        size = newSize;
    }
    
    DataManager(const DataManager& other) : size(other.size) {
        buffer = new int[size];
        for (int i = 0; i &lt; size; i++) {
            buffer[i] = other.buffer[i];
        }
    }
    
    DataManager& operator=(const DataManager& other) {
        if (this != &other) {
            delete[] buffer;
            size = other.size;
            buffer = new int[size];
            for (int i = 0; i &lt; size; i++) {
                buffer[i] = other.buffer[i];
            }
        }
        return *this;
    }
};</code></pre>
          </div>
        </div>
      </div>

      <!-- Exercise 21 -->
      <div class="exercise-card" data-difficulty="hard">
        <div class="exercise-header">
          <div class="exercise-title-group">
            <input type="checkbox" id="ex21" class="exercise-checkbox">
            <label for="ex21" class="exercise-number">Упражнение 21</label>
          </div>
          <div class="exercise-actions">
            <span class="difficulty-badge hard">ТРУДНО</span>
            <button class="show-answer-btn" data-answer="answer21">Покажи отговор</button>
          </div>
        </div>
        <div class="exercise-content">
          <div class="question">
            Имплементирайте двупосочен итератор за двусвързан списък с <code>operator++</code> и <code>operator--</code>:
            <pre><code>template&lt;typename T&gt;
class DoublyLinkedList {
    struct Node {
        T data;
        Node* prev;
        Node* next;
    };
    
    class Iterator {
    private:
        Node* current;
    public:
        // Имплементирайте всички необходими оператори
    };
};</code></pre>
          </div>
          <div class="answer" id="answer21">
            <strong>Отговор:</strong>
            <pre><code>class Iterator {
private:
    Node* current;
public:
    Iterator(Node* node) : current(node) {}
    
    // Достъп до стойността
    T& operator*() const {
        return current->data;
    }
    
    // Преместване напред (префикс)
    Iterator& operator++() {
        if (current) current = current->next;
        return *this;
    }
    
    // Преместване назад (префикс)
    Iterator& operator--() {
        if (current) current = current->prev;
        return *this;
    }
    
    // Преместване напред (постфикс)
    Iterator operator++(int) {
        Iterator temp = *this;
        ++(*this);
        return temp;
    }
    
    // Преместване назад (постфикс)
    Iterator operator--(int) {
        Iterator temp = *this;
        --(*this);
        return temp;
    }
    
    // Сравнение
    bool operator==(const Iterator& other) const {
        return current == other.current;
    }
    
    bool operator!=(const Iterator& other) const {
        return current != other.current;
    }
};</code></pre>
          </div>
        </div>
      </div>

      <!-- Exercise 22 -->
      <div class="exercise-card" data-difficulty="hard">
        <div class="exercise-header">
          <div class="exercise-title-group">
            <input type="checkbox" id="ex22" class="exercise-checkbox">
            <label for="ex22" class="exercise-number">Упражнение 22</label>
          </div>
          <div class="exercise-actions">
            <span class="difficulty-badge hard">ТРУДНО</span>
            <button class="show-answer-btn" data-answer="answer22">Покажи отговор</button>
          </div>
        </div>
        <div class="exercise-content">
          <div class="question">
            Имплементирайте пълен двусвързан списък с exception-safe вмъкване. Гарантирайте, че няма изтичане на памет дори при хвърляне на изключения.
          </div>
          <div class="answer" id="answer22">
            <strong>Отговор:</strong> Ключът е да използваме RAII и да заделим паметта така, че ако възникне изключение, всичко да се освободи автоматично:
            <pre><code>template&lt;typename T&gt;
class SafeDoublyLinkedList {
private:
    struct Node {
        T data;
        std::unique_ptr&lt;Node&gt; next; // Автоматично управление
        Node* prev; // Raw pointer назад (не притежава)
        
        Node(const T& val) : data(val), next(nullptr), prev(nullptr) {}
    };
    
    std::unique_ptr&lt;Node&gt; head;
    Node* tail;
    
public:
    SafeDoublyLinkedList() : head(nullptr), tail(nullptr) {}
    
    void add(const T& value) {
        auto newNode = std::make_unique&lt;Node&gt;(value);
        
        if (tail) {
            newNode->prev = tail;
            tail->next = std::move(newNode);
            tail = tail->next.get();
        } else {
            tail = newNode.get();
            head = std::move(newNode);
        }
    }
};</code></pre>
            <p>Използването на <code>unique_ptr</code> гарантира автоматично освобождаване при изключения.</p>
          </div>
        </div>
      </div>

      <!-- Exercise 23 -->
      <div class="exercise-card" data-difficulty="hard">
        <div class="exercise-header">
          <div class="exercise-title-group">
            <input type="checkbox" id="ex23" class="exercise-checkbox">
            <label for="ex23" class="exercise-number">Упражнение 23</label>
          </div>
          <div class="exercise-actions">
            <span class="difficulty-badge hard">ТРУДНО</span>
            <button class="show-answer-btn" data-answer="answer23">Покажи отговор</button>
          </div>
        </div>
        <div class="exercise-content">
          <div class="question">
            Разгледайте сценарий с циклични референции използвайки <code>std::shared_ptr</code>. Обяснете проблема и предоставете решение с <code>std::weak_ptr</code>:
            <pre><code>class Node {
public:
    std::shared_ptr&lt;Node&gt; next;
    std::shared_ptr&lt;Node&gt; prev;
    int data;
};</code></pre>
          </div>
          <div class="answer" id="answer23">
            <strong>Проблем:</strong> Ако два възела се сочат взаимно чрез <code>shared_ptr</code>, reference count никога не достига нула и паметта никога не се освобождава.
            <p><strong>Решение:</strong> Използвайте <code>weak_ptr</code> за едната връзка:</p>
            <pre><code>class Node {
public:
    std::shared_ptr&lt;Node&gt; next;  // Силна референция напред
    std::weak_ptr&lt;Node&gt; prev;    // Слаба референция назад
    int data;
    
    Node(int val) : data(val) {}
};</code></pre>
            <p>Така <code>next</code> притежава следващия възел, но <code>prev</code> само наблюдава предишния, без да го притежава. Това прекъсва цикличната зависимост.</p>
          </div>
        </div>
      </div>

      <!-- Exercise 24 -->
      <div class="exercise-card" data-difficulty="hard">
        <div class="exercise-header">
          <div class="exercise-title-group">
            <input type="checkbox" id="ex24" class="exercise-checkbox">
            <label for="ex24" class="exercise-number">Упражнение 24</label>
          </div>
          <div class="exercise-actions">
            <span class="difficulty-badge hard">ТРУДНО</span>
            <button class="show-answer-btn" data-answer="answer24">Покажи отговор</button>
          </div>
        </div>
        <div class="exercise-content">
          <div class="question">
            Използвайки Valgrind концептуално, анализирайте тази програма:
            <pre><code>void complexFunction() {
    int* arr1 = new int[50];
    int* arr2 = new int[100];
    
    for (int i = 0; i &lt; 50; i++) {
        arr1[i] = i;
    }
    
    arr1 = arr2; // Презаписване
    delete[] arr2;
}

int main() {
    for (int i = 0; i &lt; 1000; i++) {
        complexFunction();
    }
    return 0;
}</code></pre>
          </div>
          <div class="answer" id="answer24">
            <strong>Valgrind би докладвал:</strong>
            <ul>
              <li><strong>Memory leak:</strong> 50 * sizeof(int) * 1000 = 200,000 байта изтичат, защото <code>arr1</code> се презаписва без да се освободи първата заделена памет.</li>
              <li><strong>Invalid free/delete:</strong> <code>arr2</code> се освобождава два пъти - веднъж чрез <code>delete[] arr2</code> и втори път когато <code>arr1</code> (който вече сочи към същата памет) би трябвало да се освободи (но това не се случва в кода).</li>
            </ul>
            <p><strong>Поправка:</strong></p>
            <pre><code>void fixedFunction() {
    int* arr1 = new int[50];
    int* arr2 = new int[100];
    
    for (int i = 0; i &lt; 50; i++) {
        arr1[i] = i;
    }
    
    delete[] arr1; // Освобождаване преди презаписване
    delete[] arr2;
}</code></pre>
          </div>
        </div>
      </div>

      <!-- Exercise 25 -->
      <div class="exercise-card" data-difficulty="hard">
        <div class="exercise-header">
          <div class="exercise-title-group">
            <input type="checkbox" id="ex25" class="exercise-checkbox">
            <label for="ex25" class="exercise-number">Упражнение 25</label>
          </div>
          <div class="exercise-actions">
            <span class="difficulty-badge hard">ТРУДНО</span>
            <button class="show-answer-btn" data-answer="answer25">Покажи отговор</button>
          </div>
        </div>
        <div class="exercise-content">
          <div class="question">
            Проектирайте memory-efficient двусвързан списък, който използва sentinel nodes (фиктивни head и tail) за опростяване на граничните условия.
          </div>
          <div class="answer" id="answer25">
            <strong>Отговор:</strong>
            <pre><code>template&lt;typename T&gt;
class SentinelDoublyLinkedList {
private:
    struct Node {
        T data;
        Node* prev;
        Node* next;
        Node() : prev(nullptr), next(nullptr) {} // Sentinel конструктор
        Node(const T& val) : data(val), prev(nullptr), next(nullptr) {}
    };
    
    Node* sentinel_head; // Фиктивен head (не съдържа данни)
    Node* sentinel_tail; // Фиктивен tail (не съдържа данни)
    
public:
    SentinelDoublyLinkedList() {
        sentinel_head = new Node();
        sentinel_tail = new Node();
        sentinel_head->next = sentinel_tail;
        sentinel_tail->prev = sentinel_head;
    }
    
    ~SentinelDoublyLinkedList() {
        Node* current = sentinel_head->next;
        while (current != sentinel_tail) {
            Node* next = current->next;
            delete current;
            current = next;
        }
        delete sentinel_head;
        delete sentinel_tail;
    }
    
    void add(const T& value) {
        Node* newNode = new Node(value);
        Node* last = sentinel_tail->prev;
        
        // Вмъкване преди sentinel_tail
        newNode->prev = last;
        newNode->next = sentinel_tail;
        last->next = newNode;
        sentinel_tail->prev = newNode;
    }
    
    // Предимство: не се налагат проверки за nullptr при add/remove
};</code></pre>
            <p>Sentinel nodes опростяват логиката, защото винаги има "предишен" и "следващ" елемент.</p>
          </div>
        </div>
      </div>

      <!-- Exercise 26 -->
      <div class="exercise-card" data-difficulty="hard">
        <div class="exercise-header">
          <div class="exercise-title-group">
            <input type="checkbox" id="ex26" class="exercise-checkbox">
            <label for="ex26" class="exercise-number">Упражнение 26</label>
          </div>
          <div class="exercise-actions">
            <span class="difficulty-badge hard">ТРУДНО</span>
            <button class="show-answer-btn" data-answer="answer26">Покажи отговор</button>
          </div>
        </div>
        <div class="exercise-content">
          <div class="question">
            Създайте custom iterator, който автоматично прескача елементи, удовлетворяващи даден предикат.
          </div>
          <div class="answer" id="answer26">
            <strong>Отговор:</strong>
            <pre><code>template&lt;typename T, typename Predicate&gt;
class FilteringIterator {
private:
    Node* current;
    Node* end;
    Predicate pred;
    
    void advance() {
        while (current != end && pred(current->data)) {
            current = current->next;
        }
    }
    
public:
    FilteringIterator(Node* start, Node* end_node, Predicate p) 
        : current(start), end(end_node), pred(p) {
        advance(); // Прескачаме нежеланите елементи в началото
    }
    
    T& operator*() const {
        return current->data;
    }
    
    FilteringIterator& operator++() {
        if (current != end) {
            current = current->next;
            advance(); // Прескачаме нежелани елементи
        }
        return *this;
    }
    
    bool operator!=(const FilteringIterator& other) const {
        return current != other.current;
    }
};

// Пример: прескачане на отрицателни числа
auto it = FilteringIterator&lt;int, auto&gt;(
    list.begin(), list.end(), 
    [](int x) { return x &lt; 0; }
);</code></pre>
          </div>
        </div>
      </div>

      <!-- Exercise 27 -->
      <div class="exercise-card" data-difficulty="hard">
        <div class="exercise-header">
          <div class="exercise-title-group">
            <input type="checkbox" id="ex27" class="exercise-checkbox">
            <label for="ex27" class="exercise-number">Упражнение 27</label>
          </div>
          <div class="exercise-actions">
            <span class="difficulty-badge hard">ТРУДНО</span>
            <button class="show-answer-btn" data-answer="answer27">Покажи отговор</button>
          </div>
        </div>
        <div class="exercise-content">
          <div class="question">
            Имплементирайте move constructor и move assignment operator за двусвързан списък:
            <pre><code>template&lt;typename T&gt;
class DoublyLinkedList {
public:
    DoublyLinkedList(DoublyLinkedList&& other) noexcept {
        // Имплементирайте move constructor
    }
    
    DoublyLinkedList& operator=(DoublyLinkedList&& other) noexcept {
        // Имплементирайте move assignment
    }
};</code></pre>
          </div>
          <div class="answer" id="answer27">
            <strong>Отговор:</strong>
            <pre><code>// Move constructor
DoublyLinkedList(DoublyLinkedList&& other) noexcept 
    : head(other.head), tail(other.tail) {
    // "Крадем" ресурсите от other
    other.head = nullptr;
    other.tail = nullptr;
}

// Move assignment
DoublyLinkedList& operator=(DoublyLinkedList&& other) noexcept {
    if (this != &other) {
        // Освобождаваме собствените ресурси
        Node* current = head;
        while (current) {
            Node* next = current->next;
            delete current;
            current = next;
        }
        
        // "Крадем" ресурсите от other
        head = other.head;
        tail = other.tail;
        other.head = nullptr;
        other.tail = nullptr;
    }
    return *this;
}</code></pre>
            <p>Move семантиката позволява ефективно трансфериране на ресурси без копиране.</p>
          </div>
        </div>
      </div>

      <!-- Exercise 28 -->
      <div class="exercise-card" data-difficulty="hard">
        <div class="exercise-header">
          <div class="exercise-title-group">
            <input type="checkbox" id="ex28" class="exercise-checkbox">
            <label for="ex28" class="exercise-number">Упражнение 28</label>
          </div>
          <div class="exercise-actions">
            <span class="difficulty-badge hard">ТРУДНО</span>
            <button class="show-answer-btn" data-answer="answer28">Покажи отговор</button>
          </div>
        </div>
        <div class="exercise-content">
          <div class="question">
            Проектирайте memory pool allocator за възли на двусвързан списък за намаляване на overhead и фрагментация.
          </div>
          <div class="answer" id="answer28">
            <strong>Отговор:</strong>
            <pre><code>template&lt;typename T&gt;
class NodePool {
private:
    struct Node {
        T data;
        Node* prev;
        Node* next;
    };
    
    struct Chunk {
        Node nodes[64]; // Блок от 64 възела
        bool used[64];
        Chunk* next;
        
        Chunk() : next(nullptr) {
            for (int i = 0; i &lt; 64; i++) used[i] = false;
        }
    };
    
    Chunk* chunks;
    
public:
    NodePool() : chunks(new Chunk()) {}
    
    ~NodePool() {
        while (chunks) {
            Chunk* next = chunks->next;
            delete chunks;
            chunks = next;
        }
    }
    
    Node* allocate() {
        Chunk* current = chunks;
        while (current) {
            for (int i = 0; i &lt; 64; i++) {
                if (!current->used[i]) {
                    current->used[i] = true;
                    return &current->nodes[i];
                }
            }
            if (!current->next) {
                current->next = new Chunk();
            }
            current = current->next;
        }
        return nullptr;
    }
    
    void deallocate(Node* node) {
        Chunk* current = chunks;
        while (current) {
            if (node >= current->nodes && 
                node &lt; current->nodes + 64) {
                int index = node - current->nodes;
                current->used[index] = false;
                return;
            }
            current = current->next;
        }
    }
};</code></pre>
            <p>Memory pool намалява броя системни алокации и подобрява cache locality.</p>
          </div>
        </div>
      </div>

    </div>
  </section>
</main>
<script src="exercises-script.js"></script>
</body>
</html>
