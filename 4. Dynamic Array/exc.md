# Упражнения: Динамичен масив в C++

## Лесни упражнения (Основни концепции)

**Exercise 1 [EASY]:** Кое от следните твърдения е **вярно** за статичните масиви в C++?
- A) Размерът им може да се променя по време на изпълнение
- B) Заделят памет в heap-а
- C) Имат фиксиран размер, определен по време на компилация
- D) Използват указатели за достъп до елементи

**Exercise 2 [EASY]:** Какво е основното **предимство** на динамичните масиви спрямо статичните?
- A) По-бърз достъп до елементи
- B) Възможност за автоматично изменение на размера
- C) По-малко използване на памет
- D) По-проста синтаксис

**Exercise 3 [EASY]:** В контекста на динамичните масиви, какво представлява **capacity (капацитет)**?
- A) Броят на текущо съхранените елементи
- B) Максималният брой елементи, които могат да бъдат съхранени преди преразпределение
- C) Размерът на всеки елемент в байтове
- D) Броят на извършените операции push_back

**Exercise 4 [EASY]:** Коя операция се използва за **освобождаване** на динамично заделена памет в C++?
- A) `free()` или `delete[]`
- B) `release()`
- C) `clear()`
- D) `remove()`

**Exercise 5 [EASY]:** Каква е времевата сложност за **достъп по индекс** в динамичен масив?
- A) O(n)
- B) O(log n)
- C) O(1)
- D) O(n²)

**Exercise 6 [EASY]:** Дадена е следната декларация. Къде се разпределя паметта?
```cpp
int arr[10];
```
- A) В heap-а
- B) В стека
- C) В глобалната памет
- D) В регистрите на процесора

## Средни упражнения (Анализ и разбиране)

**Exercise 7 [MEDIUM]:** Обяснете с **2-3 изречения** защо капацитетът на динамичен масив обикновено е **по-голям** от текущия размер. Каква е целта на тази стратегия?

**Exercise 8 [MEDIUM]:** Разгледайте следния код:
```cpp
DynamicArray arr(2);
arr.push_back(10);
arr.push_back(20);
arr.push_back(30);
```
Какъв ще бъде капацитетът след третата операция `push_back`, ако масивът удвоява капацитета си при преразпределение? Обяснете стъпка по стъпка.

**Exercise 9 [MEDIUM]:** Каква е разликата между **size** и **capacity** в динамичен масив? Дайте конкретен пример със стойности.

**Exercise 10 [MEDIUM]:** Анализирайте следния фрагмент от resize метода:
```cpp
int* new_data = (int*)malloc(new_capacity * sizeof(int));
for (int i = 0; i < size; i++) {
    new_data[i] = data[i];
}
free(data);
data = new_data;
```
Каква е **времевата сложност** на този код и защо?

**Exercise 11 [MEDIUM]:** Защо използването на `std::vector` е **предпочитано** пред ръчна имплементация на динамичен масив в production код? Посочете поне **3 причини**.

**Exercise 12 [MEDIUM]:** Какво е **RAII** принципът и как се прилага при реализацията на динамичен масив? Дайте пример с конструктор и деструктор.

**Exercise 13 [MEDIUM]:** Напишете **псевдокод** за метод `pop_back()`, който премахва последния елемент от динамичен масив. Трябва ли да се преразпределя памет?

**Exercise 14 [MEDIUM]:** Идентифицирайте **грешката** в следния код:
```cpp
DynamicArray* arr = new DynamicArray(5);
arr->push_back(10);
// ... някакъв код
// програмата завършва
```

## Средно-трудни упражнения (Приложение)

**Exercise 15 [MEDIUM-HARD]:** Имплементирайте метод `insert(int index, int value)`, който вмъква елемент на определена позиция в динамичен масив. Каква е времевата сложност на този метод в най-лошия случай?

**Exercise 16 [MEDIUM-HARD]:** Обяснете концепцията за **амортизирана сложност**. Защо операцията `push_back` има амортизирана O(1) сложност, въпреки че понякога отнема O(n) време?

**Exercise 17 [MEDIUM-HARD]:** Напишете функция, която **обединява** два динамични масива в нов масив. Каква стратегия бихте използвали за определяне на началния капацитет?

**Exercise 18 [MEDIUM-HARD]:** Сравнете динамичния масив със **свързан списък** по отношение на:
- Достъп по индекс
- Вмъкване в началото
- Вмъкване в края
- Използване на памет

## Трудни упражнения (Напреднали концепции)

**Exercise 19 [HARD]:** Напишете пълна имплементация на метод `shrink_to_fit()`, който намалява капацитета на динамичен масив до текущия размер. Кога използването на такъв метод е **оправдано**?

**Exercise 20 [HARD]:** Разгледайте следната модификация на resize стратегията: вместо да удвоява капацитета, масивът го увеличава с коефициент **1.5**. 
- Какви са предимствата и недостатъците на този подход?
- Изчислете колко пъти ще се извърши преразпределение при добавяне на 100 елемента при начален капацитет 4 (за коефициент 1.5 и коефициент 2).

**Exercise 21 [HARD]:** Имплементирайте **generic** (шаблонен) клас `DynamicArray<T>`, който работи с произволен тип данни, не само с `int`. Какви допълнителни предизвикателства възникват?

**Exercise 22 [HARD]:** Анализирайте **пространствената сложност** на динамичен масив с коефициент на растеж 2. В най-лошия случай, каква е максималната неизползвана памет като процент от общата заделена памет?

**Exercise 23 [HARD]:** Имплементирайте метод `reserve(int new_capacity)`, подобен на `std::vector::reserve()`, който **предварително** заделя капацитет. Защо такъв метод може да подобри производителността?

**Exercise 24 [HARD]:** Представете си, че работите със **системи с ограничена памет** (embedded systems). Каква алтернативна стратегия за растеж бихте предложили вместо експоненциално удвояване? Обосновете отговора си.

**Exercise 25 [HARD]:** Напишете функция `benchmark()`, която **измерва времето** за добавяне на 1 милион елемента в:
1. Динамичен масив с начален капацитет 1
2. Динамичен масив с предварително резервиран капацитет 1000000
3. `std::vector` без резервация

Обяснете разликите в производителността.

---

## Отговори и насоки

**Exercise 1:** C  
**Exercise 2:** B  
**Exercise 3:** B  
**Exercise 4:** A  
**Exercise 5:** C  
**Exercise 6:** B

**Exercise 7:** Капацитетът е по-голям от размера, за да се избегнат чести операции по преразпределение на памет, които са скъпи (O(n)). Това позволява добавяне на нови елементи без веднага да се налага копиране на цялата структура.

**Exercise 8:** 
- Начало: capacity=2, size=0
- След push_back(10): size=1, capacity=2
- След push_back(20): size=2, capacity=2
- При push_back(30): size==capacity → resize → новия capacity=4
- Резултат: size=3, capacity=4

**Exercise 10:** Времевата сложност е **O(n)**, където n е size, защото се копират всички съществуващи елементи от стария масив в новия.

**Exercise 14:** Memory leak - обектът се създава с `new`, но никъде не се извиква `delete`. Трябва `delete arr;` преди края на програмата.