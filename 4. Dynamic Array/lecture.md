
Topic: Динамичен масив. Свойства. Примерна реализация. (C++)
Description: Лекцията има за цел да представи концепцията за динамични масиви в C++, техните основни свойства и предимства спрямо статичните масиви, както и примерна имплементация с обяснение на ключови операции като добавяне, изтриване и реалокация на памет.

Learning Objectives:
- Определят концепцията и нуждата от динамични масиви(По време на лекцията студентите ще могат да обяснят защо статичните масиви са ограничени и кога динамичните масиви са подходящи.)
- Разпознават основните свойства и поведение на динамичните масиви(Студентите ще могат да обсъдят капацитет, размер, реалокация и ефективност във време и памет.)
- Анализират примерна реализация на динамичен масив в C++(Студентите ще могат да разбират и обясняват ключови методи като конструктор, десктруктор, добавяне (push_back), достъп и разширяване.)
- Прилагат знания за динамични масиви за решаване на прости задачи(Студентите след лекцията ще могат да използват собствена или стандартна имплементация на динамичен масив в своите програми.)
- Идентифицират предимства и недостатъци на динамичните масиви спрямо други структури от данни(Студентите ще обсъдят кога е по-добре да се използват динамични масиви и кога други структури като списъци са по-подходящи.)
$json.lectureOutline[0].sub_topics[1].properties.details
Lecture Outline:
- 1. Introduction and Motivation
Why static arrays are limited (Students should understand the inflexibility and inefficiency in static arrays.),Need for dynamic data structures (Students should grasp practical reasons for dynamic arrays.)
- 2. Prerequisite Recap: Basic C++ Arrays and Memory
Static arrays syntax and behavior (Students recall how arrays are declared and accessed.),Pointers and dynamic memory allocation (Students should understand low-level memory concepts relevant for dynamic arrays.)
- 3. Core Concepts of Dynamic Arrays
Definition and properties (Students understand characteristics: size vs capacity, contiguous memory.),Capacity vs size (Students grasp why capacity is usually larger or equal to size.),Automatic resizing strategy (Students understand amortized complexity and why resizing is costly.)
- 4. Example Implementation of Dynamic Array in C++
Class design: private members (pointer, size, capacity) (Students should be able to articulate why each member is necessary.),Key methods: constructor, destructor (Students recognize role of resource management.),Push_back method (Students understand insertion logic and resizing necessity.),Resize helper function (Students follow the memory reallocation step.),Element access (operator[]) (Students learn about operator overloading basics.)
- 5. Comparison to Standard Library Containers
Why use std::vector? (Students understand advantages of using STL.),When to implement your own dynamic array (Students reflect on learning goals vs production code.)
- 6. Activities and Student Engagement
Think-pair-share: Discuss pros and cons of dynamic arrays (Students develop critical thinking about design trade-offs.),Code reading: Analyze provided dynamic array snippet (Students improve code comprehension skills.),Small group: Write pseudocode for push_back with resizing (Students produce clear, logical steps for insertion.)
- 7. Summary and Key Takeaways
Recap dynamic array properties and operations (Students consolidate understanding of key concepts.),Best practices and common pitfalls (Students learn how to apply knowledge safely and efficiently.)

Content:
## Лекция: Динамичен масив. Свойства. Примерна реализация. (C++)

### Въведение

Здравейте на всички! Днес ще се потопим в света на динамичните масиви в C++. Това е една фундаментална концепция в програмирането, която ще ви помогне да пишете по-гъвкав и ефективен код. Лекцията има за цел да представи концепцията за динамични масиви в C++, техните основни свойства и предимства спрямо статичните масиви, както и примерна имплементация с обяснение на ключови операции като добавяне, изтриване и реалокация на памет.

### Учебни цели

След края на тази лекция, вие ще можете да:
*   **Определяте** концепцията и нуждата от динамични масиви.
*   **Разпознавате** основните свойства и поведение на динамичните масиви.
*   **Анализирате** примерна реализация на динамичен масив в C++.
*   **Прилагате** знания за динамични масиви за решаване на прости задачи.
*   **Идентифицирате** предимства и недостатъци на динамичните масиви спрямо други структури от данни.

---

### 1. Защо статичните масиви са ограничени? (Мотивация)

Преди да се спрем на динамичните масиви, нека си припомним статичните масиви и техните ограничения.

#### Ограничения на статичните масиви

*   **Фиксиран размер:** Статичните масиви имат предварително определен размер, който **не може да се промени** по време на изпълнение на програмата. Това означава, че трябва да знаем точно колко елементи ще съхраняваме, което често не е възможно в реални сценарии.
    *   *Пример:* Ако декларирате `int arr[10];`, масивът винаги ще може да съхранява точно 10 елемента, нито повече, нито по-малко.
*   **Негъвкавост:** Ако се окаже, че имаме нужда от повече елементи от предварително зададения размер, не можем да добавим нови елементи без да създадем нов масив и да прехвърлим стойностите. Това води до допълнителна работа и възможни грешки.
*   **Неефективност на паметта:**
    *   Ако заделим твърде много памет (например `int arr[1000];` за 10 елемента), тя може да остане неизползвана, което е загуба на ресурси.
    *   Ако заделим твърде малко памет, може да се наложи често пренареждане и копиране на данни, което намалява производителността.

#### Нужда от динамични структури от данни

*   **Динамичен размер:** Динамичните масиви позволяват добавяне и премахване на елементи по време на изпълнение, като автоматично управляват размера на заделената памет. Това прави програмите по-гъвкави и по-лесни за поддръжка.
*   **Практически причини:** В много приложения (обработка на данни, работа с потребителски вход, съхранение на променливи количества информация) е необходимо да се използват структури, които могат да се адаптират към нуждите на програмата.
*   **Ефективност:** Динамичните масиви предлагат добър баланс между скорост и гъвкавост. Те позволяват бърз произволен достъп до елементи, както и лесно добавяне и премахване, което ги прави подходящи за много задачи.
*   **Примери от реалния свят:**
    *   Съхранение на списък с потребители, който се променя с времето.
    *   Обработка на входни данни с неизвестен брой елементи.
    *   Реализация на стекове, опашки и други структури от данни, които изискват променлив размер.

Тези аспекти ни помагат да разберем защо е необходимо да се използват динамични масиви и как те решават ограниченията на статичните масиви.

---

### 2. Преговор: Основни масиви и памет в C++

Преди да се потопим в динамичните масиви, е важно да преговорим основните концепции за статични масиви и управление на паметта в C++. Те са от решаващо значение за разбирането на това как работят динамичните масиви.

#### Статични масиви: Синтаксис и поведение

*   **Декларация:** Статичен масив се декларира с фиксиран размер по време на компилация.
    ```cpp
    int arr[5]; // Декларира масив от 5 цели числа
    ```
*   **Инициализация:** Масивите могат да бъдат инициализирани по време на декларация.
    ```cpp
    int arr[5] = {1, 2, 3, 4, 5};
    ```
*   **Достъп до елементи:** Елементите се достъпват чрез индекси, започващи от 0.
    ```cpp
    arr[0] = 10; // Присвоява 10 на първия елемент
    int x = arr[2]; // Извлича третия елемент
    ```
*   **Фиксиран размер:** Размерът на статичен масив не може да бъде променян след декларацията.
    ```cpp
    int arr[5]; // Размерът е фиксиран на 5
    ```
*   **Разпределение на памет:** Статичните масиви се разпределят в **стека (stack)**. Паметта се управлява автоматично от компилатора.

#### Указатели и динамично разпределение на памет

*   **Указатели:** Указателят е променлива, която съхранява адреса на паметта на друга променлива.
    ```cpp
    int* ptr = &arr[0]; // ptr сочи към първия елемент на arr
    ```
*   **Динамично разпределение на памет:** Динамичните масиви се създават с помощта на указатели и динамично разпределение на памет.
    ```cpp
    int* dynamic_arr = new int[5]; // Разпределя памет за 5 цели числа в хийпа
    ```
*   **Достъп до елементи:** Елементите се достъпват с помощта на аритметика на указатели или нотация за масиви.
    ```cpp
    dynamic_arr[0] = 10; // Присвоява 10 на първия елемент
    int y = dynamic_arr[2]; // Извлича третия елемент
    ```
*   **Освобождаване на памет:** Паметта, разпределена с `new`, трябва да бъде освободена с `delete[]`, за да се избегнат течове на памет (memory leaks).
    ```cpp
    delete[] dynamic_arr; // Освобождава разпределената памет
    ```
*   **Хийп (Heap) срещу Стек (Stack):**
    *   **Стек:** Използва се за статични масиви и локални променливи. Паметта се управлява автоматично. Бърз достъп, но ограничен размер.
    *   **Хийп:** Използва се за динамични масиви. Паметта трябва да се управлява ръчно. По-бавен достъп, но голям и гъвкав размер.

#### Ключови неща за запомняне

*   **Статичните масиви** имат фиксиран размер и се разпределят в стека.
*   **Динамичните масиви** имат променлив размер и се разпределят в хийпа.
*   **Указателите** се използват за управление на динамична памет.
*   **Управлението на паметта** е от решаващо значение за избягване на течове на памет и грешки при достъп до памет (segmentation faults).

Този преговор гарантира, че имате солидна основа в основните концепции за масиви и памет в C++, които са от съществено значение за разбирането и реализирането на динамични масиви.

---

### 3. Основни концепции на динамичните масиви

#### Определение и свойства

**Динамичният масив** е структура от данни, която позволява размерът на масива да бъде променян по време на изпълнение на програмата, за разлика от статичните масиви, чийто размер е фиксиран по време на компилация. В C++ динамичните масиви обикновено се реализират с помощта на указатели и динамично разпределение на памет (с `new` и `delete`), или по-често с помощта на класа `std::vector` от Standard Template Library (STL).

**Ключови свойства:**
*   **Размер (Size):** Броят на елементите, които в момента се съхраняват в масива.
*   **Капацитет (Capacity):** Общият брой елементи, които масивът може да побере, преди да се наложи преразпределение на памет.
*   **Непрекъсната памет:** Елементите се съхраняват в непрекъснат блок памет, което позволява ефективен достъп по индекс (времева сложност O(1)).

#### Капацитет срещу Размер

*   **Размер (Size):** Това е действителният брой елементи, които в момента са в масива. Той се променя при добавяне или премахване на елементи.
*   **Капацитет (Capacity):** Това е максималният брой елементи, които масивът може да побере, без да преразпределя памет. Капацитетът обикновено е по-голям или равен на размера.

**Защо капацитетът е по-голям или равен на размера:**
*   **Ефективност:** Като има капацитет, който е по-голям от текущия размер, масивът може да побере допълнителни елементи, без веднага да се налага преразпределение на памет. Това намалява честотата на скъпоструващите операции за преразпределение на памет.
*   **Производителност:** Когато размерът достигне капацитета, масивът трябва да бъде преоразмерен, което включва разпределяне на нов блок памет, копиране на съществуващи елементи и освобождаване на стария блок. Тази операция е скъпа, така че наличието на допълнителен капацитет помага за амортизиране на тези разходи за множество вмъквания.

#### Стратегия за автоматично преоразмеряване

*   **Преоразмеряване:** Когато размерът на масива достигне капацитета си, масивът се преоразмерява. Това обикновено включва:
    1.  Разпределяне на нов блок памет с по-голям капацитет.
    2.  Копиране на съществуващите елементи в новия блок.
    3.  Освобождаване на стария блок.
    4.  Актуализиране на капацитета и размера.

*   **Амортизирана сложност (Amortized Complexity):** Цената на преоразмеряването се разпределя върху множество вмъквания. Например, ако масивът удвоява капацитета си всеки път, когато трябва да се преоразмери, амортизираната цена за добавяне на елемент е O(1). Това означава, че средно всяка операция по вмъкване отнема постоянно време, въпреки че някои отделни вмъквания може да отнемат повече време поради преоразмеряване.

*   **Защо преоразмеряването е скъпо:**
    *   **Разпределение на памет:** Разпределянето на нов блок памет е относително скъпа операция.
    *   **Копиране на елементи:** Копирането на всички съществуващи елементи в новия блок също е скъпо, особено за големи масиви.
    *   **Освобождаване на памет:** Освобождаването на стария блок памет е необходимо, за да се избегнат течове на памет.

---

### 4. Примерна реализация на динамичен масив в C++

Динамичният масив е структура от данни, която позволява съхранение на елементи с възможност за динамично изменение на размера. За разлика от статичните масиви, които имат фиксиран размер, динамичните масиви растат и се свиват според нуждите на програмата.

## Архитектура на класа `DynamicArray`

Реализацията на динамичен масив в C++ обикновено се осъществява чрез клас със следната структура:

**Приватни членове**

Класът трябва да съдържа три основни приватни члена:

*   **Указател към данни (`int* data`)** — съхранява адреса на динамично заделената памет, където се намират действителните елементи на масива.
*   **Размер (`int size`)** — отследява броя на елементите, които са в момента съхранени в масива.
*   **Капацитет (`int capacity`)** — представя общия брой елементи, за които е резервирана памет.

Защо всеки член е необходим? Указателят позволява управление на динамична памет, размерът информира програмистите колко елемента реално съществуват, а капацитетът е оптимизационен механизъм, който избягва постоянното преразпределение на памет при всяко добавяне на елемент.

## Конструктор и Деструктор

**Конструктор**

Конструкторът инициализира динамичния масив с начален капацитет:

```cpp
class DynamicArray {
private:
    int* data;
    int size;
    int capacity;

public:
    DynamicArray(int initial_capacity = 4) {
        capacity = initial_capacity;
        size = 0;
        // Използваме malloc за съвместимост с free в деструктора
        data = (int*)malloc(capacity * sizeof(int));
        if (!data) {
            fprintf(stderr, "Memory allocation failed\n");
            // В реално приложение тук бихме хвърлили изключение
        }
    }
    // ... други методи
};
```

При създаване на обект, конструкторът резервира начална памет с обикновено избран капацитет (например 4 елемента). Това отдалечава необходимостта от преразпределение на памет при първите няколко операции.

**Деструктор**

Деструкторът е критичен за управление на ресурсите:

```cpp
    ~DynamicArray() {
        free(data); // Освобождава динамично заделената памет
        data = nullptr; // Избягва dangling pointer
    }
};
```

Деструкторът освобождава динамично заделената памет, когато обектът се унищожава. Това предотвратява утечки на памет, които биха възникнали, ако паметта не бъде върната към системата. Този подход е част от принципа **RAII (Resource Acquisition Is Initialization)** – ресурсите се придобиват в конструктора и се освобождават в деструктора.

## Метод `push_back`

Методът `push_back` добавя нов елемент в края на масива:

```cpp
    int push_back(int value) {
        // Проверяваме дали е необходимо разширяване
        if (size >= capacity) {
            if (resize() == -1) {
                return -1; // Грешка при преразпределение
            }
        }
        
        // Добавяме новия елемент
        data[size] = value;
        size++;
        return 1; // Успешно добавяне
    }
```

Логиката на `push_back` работи в две фази. Първо, проверява дали броят на елементите е достигнал капацитета. Ако е така, извиква помощна функция за преразпределение (`resize`). След това поставя новия елемент на позиция `size` и увеличава `size`.

## Помощна функция за преразпределение (`resize`)

Функцията `resize` е ключова за управление на растежа на масива:

```cpp
    int resize() {
        int new_capacity = capacity * 2; // Удвояваме капацитета
        
        // Заделяме нова памет
        int* new_data = (int*)malloc(new_capacity * sizeof(int));
        if (!new_data) {
            fprintf(stderr, "Memory reallocation failed\n");
            return -1; // Грешка при заделяне
        }
        
        // Копираме старите данни в новата памет
        for (int i = 0; i < size; i++) {
            new_data[i] = data[i];
        }
        
        // Освобождаваме старата памет
        free(data);
        
        // Обновяваме указателя и капацитета
        data = new_data;
        capacity = new_capacity;
        
        return 1; // Успешно преразпределение
    }
```

Процесът на преразпределение включва няколко критични стъпки. Когато капацитетът е надвишен, функцията алокира нова памет с удвоен размер. След това копира всички съществуващи елементи от старата памет в новата. Накрая, освобождава старата памет и обновява указателя (`data`) към новото място, както и `capacity`.

## Достъп до елементи (`get` и `operator[]`)

Претоварването на оператора за индексиране (`[]`) позволява интуитивен достъп:

```cpp
    int get(int index) {
        if (index < 0 || index >= size) {
            fprintf(stderr, "Index out of bounds\n");
            // В реално приложение тук бихме хвърлили std::out_of_range изключение
            return -1; 
        }
        return data[index];
    }
    
    // Претоварване на оператора [] за удобен достъп
    int operator[](int index) {
        // За простота, тук не се прави проверка, но е добре да има такава или да се използва get()
        return data[index]; 
    }
```

Операторът `[]` обикновено се претоварва, за да осигури познатия синтаксис за достъп до елементи. Достъпът чрез `data[index]` осъществява достъп до елемента на позиция `index` с времева сложност O(1). Функцията `get` предоставя по-безопасен достъп с проверка за валидност на индекса.

## Пълен пример за реализация

```cpp
#include <stdio.h> // За fprintf, printf
#include <stdlib.h> // За malloc, free

class DynamicArray {
private:
    int* data;
    int size;
    int capacity;
    
    // Помощна функция за преразпределение на памет
    int resize() {
        int new_capacity = capacity * 2; // Удвояваме капацитета
        
        // Заделяме нова памет
        int* new_data = (int*)malloc(new_capacity * sizeof(int));
        
        if (!new_data) {
            fprintf(stderr, "Memory reallocation failed\n");
            return -1; // Индикация за грешка
        }
        
        // Копираме старите данни в новата памет
        for (int i = 0; i < size; i++) {
            new_data[i] = data[i];
        }
        
        // Освобождаваме старата памет
        free(data);
        
        // Обновяваме указателя към новата памет и новия капацитет
        data = new_data;
        capacity = new_capacity;
        
        return 1; // Успешно преразпределение
    }
    
public:
    // Конструктор: инициализира масива с начален капацитет
    DynamicArray(int initial_capacity = 4) {
        capacity = initial_capacity;
        size = 0;
        data = (int*)malloc(capacity * sizeof(int));
        if (!data) {
             fprintf(stderr, "Initial memory allocation failed\n");
             // В реален код тук бихме хвърлили std::bad_alloc
        }
    }
    
    // Деструктор: освобождава заделената памет
    ~DynamicArray() {
        free(data);
        data = nullptr; // Избягване на dangling pointer
    }
    
    // Добавя елемент в края на масива
    int push_back(int value) {
        if (size >= capacity) { // Проверяваме дали има място
            if (resize() == -1) {
                return -1; // Грешка при преразпределение
            }
        }
        data[size] = value; // Добавяме елемента
        size++; // Увеличаваме размера
        return 1; // Успешно добавяне
    }
    
    // Връща елемент по индекс (с проверка за граници)
    int get(int index) {
        if (index < 0 || index >= size) {
            fprintf(stderr, "Index out of bounds\n");
            return -1; // Индикация за грешка
        }
        return data[index];
    }

    // Претоварване на оператора [] за по-удобен достъп
    int operator[](int index) {
        // Внимание: Този оператор не прави проверка за граници по подразбиране
        // Можете да извикате get() за безопасен достъп, но с лек овърхед
        return data[index];
    }
    
    // Връща текущия брой елементи
    int getSize() { return size; }
    // Връща текущия капацитет на масива
    int getCapacity() { return capacity; }
};

int main() {
    DynamicArray arr(2); // Създаваме динамичен масив с начален капацитет 2
    
    printf("Initial Size: %d, Initial Capacity: %d\n", arr.getSize(), arr.getCapacity()); // 0, 2

    arr.push_back(10); // Size: 1, Capacity: 2
    arr.push_back(20); // Size: 2, Capacity: 2
    printf("After 2 push_backs: Size: %d, Capacity: %d\n", arr.getSize(), arr.getCapacity()); // 2, 2

    arr.push_back(30); // Size: 3, Capacity: 4 (triggered resize)
    printf("After 3rd push_back: Size: %d, Capacity: %d\n", arr.getSize(), arr.getCapacity()); // 3, 4

    arr.push_back(40); // Size: 4, Capacity: 4
    printf("After 4th push_back: Size: %d, Capacity: %d\n", arr.getSize(), arr.getCapacity()); // 4, 4
    
    arr.push_back(50); // Size: 5, Capacity: 8 (triggered resize)
    printf("After 5th push_back: Size: %d, Capacity: %d\n", arr.getSize(), arr.getCapacity()); // 5, 8
    
    printf("Elements in array: ");
    for (int i = 0; i < arr.getSize(); i++) {
        printf("%d ", arr.get(i)); // Използваме get() за безопасен достъп
    }
    printf("\n"); // Изход: 10 20 30 40 50

    printf("Element at index 1: %d\n", arr[1]); // Използваме operator[]: 20
    printf("Element at index 4: %d\n", arr[4]); // Използваме operator[]: 50

    // Опит за достъп извън граници
    arr.get(10); // Ще изведе "Index out of bounds" и ще върне -1
    
    return 0;
}
```

## Ключови концепции

*   **Управление на ресурсите (RAII):** Конструкторът и деструкторът работят заедно, за да управляват динамичната памет. Това е известно като RAII (Resource Acquisition Is Initialization) принцип — ресурсите се придобиват в конструктора и се отпускат в деструктора.
*   **Амортизирана сложност:** Въпреки че `push_back` обикновено работи в O(1), операцията на преразпределение отнема O(n). Чрез удвояване на капацитета, броят на преразпределенията намалява експоненциално, което дава **амортизирана O(1) времева сложност** за `push_back`.
*   **Операторно претоварване:** Претоварването на оператора `[]` позволява класът на динамичния масив да бъде използван като обикновен масив, което улеснява програмирането и повишава четимостта на кода.

---

### 5. Сравнение с контейнерите от стандартната библиотека (STL)

След като разбрахме как се изгражда динамичен масив от нулата, е важно да погледнем към практическото приложение в C++ и да сравним нашата реализация с `std::vector` от STL.

#### Защо да използваме `std::vector`?

`std::vector` е стандартният динамичен масив в C++ и е предпочитаният избор в повечето реални проекти.

*   **Автоматично управление на паметта:** `std::vector` автоматично разпределя и освобождава памет, което избягва чести грешки като memory leaks и dangling pointers. Това е особено важно за начинаещи програмисти и значително намалява грешките.
*   **Динамичен размер:** Векторът автоматично увеличава размера си при добавяне на нови елементи, без да е нужно да се грижим за реалокация на паметта. Стратегията за растеж е оптимизирана.
*   **Бърз достъп по индекс:** Достъпът до елементите е със сложност O(1), както при обикновен масив.
*   **Интеграция с STL алгоритми:** `std::vector` работи директно с алгоритми от STL като `std::sort`, `std::find`, `std::accumulate` и други, което улеснява обработката на данни.
*   **Безопасност и сигурност:** STL контейнерите предлагат методи за безопасен достъп до елементи (например, `.at()`), които хвърлят изключение (`std::out_of_range`) при опит за достъп извън границите.
*   **Итератори:** Всички STL контейнери, включително `std::vector`, поддържат итератори, които позволяват лесен обход и работа с алгоритми.
*   **Оптимизация и тестваност:** `std::vector` е силно оптимизиран и тестван от години, което гарантира висока производителност и надеждност в реални проекти.

#### Кога да реализираме собствен динамичен масив?

Въпреки предимствата на `std::vector`, има ситуации, в които може да се наложи или да е полезно да реализираме собствен динамичен масив:

*   **Образователни цели:** Реализацията на собствен динамичен масив е отличен начин за разбиране на основните принципи на управление на паметта, реалокация и работа с указатели. Това помага на студентите да осъзнаят как работят STL контейнерите отвътре.
*   **Специализирани нужди:** В редки случаи може да се наложи реализация на специализирана структура с уникални свойства или ограничения, които не са покрити от стандартните контейнери (напр. специфична стратегия за растеж, различни гаранции за памет).
*   **Производителност (много рядко):** В изключително редки случаи, когато има изключително строги изисквания за производителност или памет и `std::vector` не може да ги удовлетвори, може да се реализира по-тясно оптимизирана структура. Това обаче изисква дълбоко разбиране на C++ и системно програмиране.
*   **Разбиране на STL:** Реализацията на собствен динамичен масив помага на студентите да оценят сложността и предимствата на STL контейнерите, както и да разберат защо те са предпочитан избор в производствен код.

#### Заключение

*   **В образователна среда:** Реализацията на собствен динамичен масив е ценно упражнение, което помага за разбиране на основните принципи на C++ и STL.
*   **В производствен код:** Винаги се предпочита използването на `std::vector` или други STL контейнери, тъй като те са надеждни, оптимизирани и предлагат богат набор от функционалности.
*   **Баланс между учене и практика:** Студентите трябва да разберат, че реализацията на собствени структури е полезна за учене, но в реални проекти трябва да се използват готови и добре тествани решения като STL контейнерите.

---

### 6. Дейности и ангажиране на студентите

За да затвърдим наученото, нека направим няколко интерактивни упражнения.

#### 1. "Помисли-Сдружи-Сподели": Дискусия за плюсове и минуси на динамичните масиви

*   **Описание на дейността:** Студентите работят по двойки, за да обсъдят и анализират **предимствата и недостатъците** на динамичните масиви в сравнение със статичните масиви и други структури от данни (напр. свързани списъци, `std::vector`).
*   **Насочващи въпроси:**
    *   Кога е по-добре да се използва динамичен масив вместо статичен масив?
    *   Какви са рисковете от ръчното управление на паметта (напр. течове на памет, "dangling pointers")?
    *   Как динамичните масиви се сравняват с `std::vector` по отношение на гъвкавостта и безопасността?
*   **Резултат от обучението:** Студентите развиват **критично мислене** относно компромисите в дизайна и разбират **важността от избора на правилната структура от данни** за даден проблем.

#### 2. Прочитане на код: Анализирайте предоставен фрагмент за динамичен масив

*   **Описание на дейността:** Ще ви бъде предоставен **кратък C++ код**, който демонстрира разпределение, преоразмеряване и освобождаване на динамичен масив (напр. опростена версия на клас за динамичен масив с методи `push_back` и `resize`).
*   **Задача:** Студентите анализират кода, за да идентифицират:
    *   Как се разпределя и освобождава паметта.
    *   Как масивът се преоразмерява, когато свърши мястото.
    *   Потенциални грешки или проблеми с управлението на паметта (напр. забравяне да се изтрие старата памет).
*   **Примерен фрагмент:**
    ```cpp
    // Разгледайте push_back и resize методите от нашата примерна реализация
    // Обърнете внимание на malloc/free и копирането на елементи.
    ```
*   **Резултат от обучението:** Студентите подобряват **уменията си за разбиране на код** и се научават да разпознават **ключови операции** в реализациите на динамични масиви.

#### 3. Малка група: Напишете псевдокод за `push_back` с преоразмеряване

*   **Описание на дейността:** В малки групи студентите пишат **псевдокод** за операция `push_back`, която автоматично преоразмерява масива, когато той е пълен.
*   **Задача:**
    *   Дефинирайте стъпките за добавяне на елемент в края на масива.
    *   Включете логика за проверка дали масивът е пълен и преоразмеряване (напр. удвояване на капацитета).
    *   Обсъдете как да копирате съществуващите елементи в новия масив и да актуализирате указателя.
*   **Примерен псевдокод:**
    ```
    ФУНКЦИЯ push_back(стойност):
        АКО размер >= капацитет ТОГАВА:
            нов_капацитет = капацитет * 2
            създай нов_масив с нов_капацитет
            за ВСЕКИ елемент в текущ_масив:
                копирай елемент в нов_масив
            освободи паметта на текущ_масив
            текущ_масив = нов_масив
            капацитет = нов_капацитет
        КРАЙ АКО
        добави стойност в текущ_масив[размер]
        увеличи размер с 1
    КРАЙ ФУНКЦИЯ
    ```
*   **Резултат от обучението:** Студентите създават **ясни, логически стъпки** за вмъкване и придобиват по-задълбочено разбиране на **преразпределението на памет** и **поведението на динамичните масиви**.

---

### 7. Резюме и ключови изводи за динамични масиви

## Преглед на свойства и операции

Динамичните масиви представляват мощна структура от данни, която предоставя гъвкавост при управлението на памет и размера на данните. Те се отличават от статичните масиви с възможността да **променят размера си по време на изпълнението на програмата**, без да е необходимо да знаем предварително точния брой елементи, които ще съхраняват.

Основната идея е, че динамичният масив поддържа три критични компонента: **указател на участък памет**, който съхранява елементите; **размер (size)**, който представлява броя заделени елементи; и **капацитет (capacity)**, който е броят елементи, за които е резервирана памет. Този дизайн позволява системата да работи ефективно, като избягва прекомерното разходване на памет и същевременно осигурява достатъчно място за растеж.

### Ключови операции

*   **Достъп по индекс** – операцията `get(i)` позволява връщане на елемента на позиция `i` за време O(1), което е еквивалентно на достъпа в статичните масиви.
*   **Добавяне на елементи** – операцията `push_back()` добавя елементи в края на масива. Критичното тук е, че достигането на амортизирана сложност O(1) се постига чрез **предварително разпределяне на памет** с коефициент на растеж. Обикновено се използват коефициенти като ×1.5, ×2 или ×1.125, които представляват компромис между честотата на преразпределенията и количеството на потенциално неизползвана памет.
*   **Реалокация на памет** – когато капацитетът е изчерпан, системата автоматично удвоява (или по-точно, разширява по избрания коефициент) капацитета, копира съществуващите елементи в новата памет и освобождава старото пространство.
*   **Изтриване и свиване** – елементите могат да бъдат премахнати, а при определени условия (например, когато броят елементи падне до четвърт от капацитета) масивът може да се свие, за да се намали използваната памет.

## Сравнение: статични спрямо динамични масиви

| Характеристика          | Статични масиви            | Динамични масиви                   |
| :---------------------- | :------------------------- | :--------------------------------- |
| **Размер**              | Фиксиран при създаването   | Променя се автоматично             |
| **Използване на памет** | Винаги еднакво             | Адаптира се към данните            |
| **Добавяне на елементи**| Невъзможно извън размера   | Автоматично разширение             |
| **Достъп по индекс**    | O(1)                       | O(1)                               |
| **Гъвкавост**           | Ниска                      | Висока                             |
| **Режийност**           | Минимална                  | Някои копирания при реалокация     |

## Най-добри практики

*   **Избор на подходящата структура** – динамични масивите са идеални за задачи, при които **често се добавят елементи в края** и където е важен бързият достъп по индекс. Те са по-малко подходящи за сценарии с чести вмъквания в средата на масива, където други структури като свързани списъци могат да бъдат по-ефективни.
*   **Управление на паметта** – в C++ се препоръчва използването на **`std::vector`** вместо ръчното управление с `new[]` и `delete[]`, тъй като `std::vector` инкапсулира логиката за управление на паметта и автоматично се грижи за освобождаването. Това намалява риска от течове на памет и прави кода по-безопасен.
*   **Предварително разпределение** – ако е известен приблизително броят елементи, се препоръчва използването на методи за предварително разпределение на необходимия капацитет (напр. `std::vector::reserve()`), което избягва множество преразпределения.

## Често срещани грешки

*   **Превишаване на границите** – достъпът до елементи извън размера на масива е причина за неопределено поведение. Всяко обръщение трябва да проверява дали индексът е в допустимите граници.
*   **Утечки на памет** – при ръчно управление на паметта с `malloc`/`free` или `new`/`delete` е лесно да забравим да освободим паметта, което води до утечки. Това се избягва чрез използване на RAII принципа и `std::vector`.
*   **Неправилна реалокация** – ако не се използват подходящи коефициенти на растеж, масивът може да преживее твърде много преразпределения (което е бавно) или да разходва твърде много памет (което е неефективно).
*   **Игнориране на капацитета** – студентите често объркват размера и капацитета; размерът показва броя валидни елементи, а капацитетът е резервираното място. Правилното управление на тези две стойности е критично за оптималната работа.

## Ключови изводи

Динамичните масиви предоставят баланс между **гъвкавостта при управлението на паметта** и **ефективния достъп до данни**. Те автоматично управляват паметта, освобождавайки програмиста от необходимостта да знае предварително размера на данните. **Амортизираната O(1) сложност за добавяне** се достига благодарение на стратегията на предварително разпределение.

За успешното използване на динамичните масиви е важно да се разбере механизмът на реалокация, да се избегнат честите грешки при управление на паметта и да се избира подходящата структура за конкретната задача. В C++ използването на `std::vector` е препоръчителният начин, тъй като той абстрахира сложностите и осигурява безопасност.

Благодаря за вниманието!
