---
title: "–£–ø—Ä–∞–∂–Ω–µ–Ω–∏—è"
sidebar_position: 2
slug: exercises
tags: [exercises, practice, graphs, bfs, dfs, adjacency-matrix, adjacency-list]
---

import ExerciseCard from '@site/src/components/Exercise/ExerciseCard';
import ProgressTracker from '@site/src/components/Exercise/ProgressTracker';
import CollapsibleSection from '@site/src/components/CollapsibleSection';
import InfoBox from '@site/src/components/InfoBoxes/InfoBox';
import WarningBox from '@site/src/components/InfoBoxes/WarningBox';

# –£–ø—Ä–∞–∂–Ω–µ–Ω–∏—è - –ì—Ä–∞—Ñ–∏: –ü—Ä–µ–¥—Å—Ç–∞–≤—è–Ω–µ –∏ –ê–ª–≥–æ—Ä–∏—Ç–º–∏

<ProgressTracker />

---

## –û—Å–Ω–æ–≤–Ω–∏ –£–ø—Ä–∞–∂–Ω–µ–Ω–∏—è (EASY)

<ExerciseCard
  difficulty="easy"
  timeEstimate="15 min"
  tags={["theory", "terminology"]}
>

### –¢–µ—Ä–º–∏–Ω–æ–ª–æ–≥–∏—è –Ω–∞ –ì—Ä–∞—Ñ–∏—Ç–µ

–î–µ—Ñ–∏–Ω–∏—Ä–∞–π—Ç–µ —Å–ª–µ–¥–Ω–∏—Ç–µ —Ç–µ—Ä–º–∏–Ω–∏ —Å—ä—Å —Å–≤–æ–∏ –¥—É–º–∏ –∏ –¥–∞–π—Ç–µ —Ä–µ–∞–ª–µ–Ω –ø—Ä–∏–º–µ—Ä –∑–∞ –≤—Å–µ–∫–∏:
- **–í—Ä—ä—Ö (Vertex)**
- **–†–µ–±—Ä–æ (Edge)**
- **–°—Ç–µ–ø–µ–Ω (Degree)**
- **–°—ä—Å–µ–¥—Å—Ç–≤–æ (Adjacency)**

</ExerciseCard>

<CollapsibleSection title="‚úÖ –†–µ—à–µ–Ω–∏–µ" icon="‚úÖ">

**–î–µ—Ñ–∏–Ω–∏—Ü–∏–∏:**

1. **–í—Ä—ä—Ö (Vertex):** –û—Ç–¥–µ–ª–Ω–∞ —Ç–æ—á–∫–∞ –∏–ª–∏ –≤—ä–∑–µ–ª –≤ –≥—Ä–∞—Ñ–∞. –ü—Ä–µ–¥—Å—Ç–∞–≤–ª—è–≤–∞ –æ–±–µ–∫—Ç –∏–ª–∏ –µ–¥–∏–Ω–∏—Ü–∞.
   - *–ü—Ä–∏–º–µ—Ä:* –í —Å–æ—Ü–∏–∞–ª–Ω–∞ –º—Ä–µ–∂–∞, –≤—Å–µ–∫–∏ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª –µ –≤—Ä—ä—Ö.

2. **–†–µ–±—Ä–æ (Edge):** –í—Ä—ä–∑–∫–∞ –∏–ª–∏ –ª–∏–Ω–∏—è, –∫–æ—è—Ç–æ —Å–≤—ä—Ä–∑–≤–∞ –¥–≤–∞ –≤—ä—Ä—Ö–∞.
   - *–ü—Ä–∏–º–µ—Ä:* –ü—Ä–∏—è—Ç–µ–ª—Å–∫–∞—Ç–∞ –≤—Ä—ä–∑–∫–∞ –º–µ–∂–¥—É –¥–≤–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–∏ –≤ —Å–æ—Ü–∏–∞–ª–Ω–∞ –º—Ä–µ–∂–∞.

3. **–°—Ç–µ–ø–µ–Ω (Degree):** –ë—Ä–æ—è—Ç –Ω–∞ —Ä–µ–±—Ä–∞—Ç–∞, —Å–≤—ä—Ä–∑–∞–Ω–∏ —Å –¥–∞–¥–µ–Ω –≤—Ä—ä—Ö.
   - *–ü—Ä–∏–º–µ—Ä:* –ê–∫–æ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª –∏–º–∞ 5 –ø—Ä–∏—è—Ç–µ–ª–∏, –Ω–µ–≥–æ–≤–∞—Ç–∞ —Å—Ç–µ–ø–µ–Ω –µ 5.

4. **–°—ä—Å–µ–¥—Å—Ç–≤–æ (Adjacency):** –î–≤–∞ –≤—ä—Ä—Ö–∞ —Å–∞ —Å—ä—Å–µ–¥–Ω–∏, –∞–∫–æ –∏–º–∞ —Ä–µ–±—Ä–æ –º–µ–∂–¥—É —Ç—è—Ö.
   - *–ü—Ä–∏–º–µ—Ä:* –î–≤–∞ –≥—Ä–∞–¥–∞ —Å–∞ —Å—ä—Å–µ–¥–Ω–∏, –∞–∫–æ –∏–º–∞ –¥–∏—Ä–µ–∫—Ç–µ–Ω –ø—ä—Ç (—Ä–µ–±—Ä–æ) –º–µ–∂–¥—É —Ç—è—Ö.

</CollapsibleSection>

---

<ExerciseCard
  difficulty="easy"
  timeEstimate="10 min"
  tags={["theory", "classification"]}
>

### –ö–ª–∞—Å–∏—Ñ–∏–∫–∞—Ü–∏—è –Ω–∞ –ì—Ä–∞—Ñ–∏

–ó–∞ –≤—Å–µ–∫–∏ —Å—Ü–µ–Ω–∞—Ä–∏–π, –æ–ø—Ä–µ–¥–µ–ª–µ—Ç–µ –¥–∞–ª–∏ –≥—Ä–∞—Ñ—ä—Ç —Ç—Ä—è–±–≤–∞ –¥–∞ –±—ä–¥–µ:
- –ù–∞—Å–æ—á–µ–Ω –∏–ª–∏ –ù–µ–Ω–∞—Å–æ—á–µ–Ω
- –ü—Ä–µ—Ç–µ–≥–ª–µ–Ω –∏–ª–∏ –ù–µ–ø—Ä–µ—Ç–µ–≥–ª–µ–Ω

**a)** Twitter follow –æ—Ç–Ω–æ—à–µ–Ω–∏—è (A —Å–ª–µ–¥–≤–∞ B –Ω–µ –æ–∑–Ω–∞—á–∞–≤–∞, —á–µ B —Å–ª–µ–¥–≤–∞ A)

**b)** –†–∞–∑—Å—Ç–æ—è–Ω–∏–µ –º–µ–∂–¥—É –≥—Ä–∞–¥–æ–≤–µ –Ω–∞ –∫–∞—Ä—Ç–∞

**c)** Facebook –ø—Ä–∏—è—Ç–µ–ª—Å—Ç–≤–∞

**d)** –ï–¥–Ω–æ–ø–æ—Å–æ—á–Ω–∏ —É–ª–∏—Ü–∏ –≤ –≥—Ä–∞–¥ —Å –≤—Ä–µ–º–µ–Ω–∞ –∑–∞ –∑–∞–¥—Ä—ä—Å—Ç–≤–∞–Ω–µ

</ExerciseCard>

<CollapsibleSection title="‚úÖ –†–µ—à–µ–Ω–∏–µ" icon="‚úÖ">

**a) Twitter follow –æ—Ç–Ω–æ—à–µ–Ω–∏—è:**
- **–ù–∞—Å–æ—á–µ–Ω** - —Å–ª–µ–¥–≤–∞–Ω–µ—Ç–æ –µ –µ–¥–Ω–æ—Å—Ç—Ä–∞–Ω–Ω–æ
- **–ù–µ–ø—Ä–µ—Ç–µ–≥–ª–µ–Ω** - –≤—Å–∏—á–∫–∏ —Å–ª–µ–¥–≤–∞–Ω–∏—è —Å–∞ –µ–¥–Ω–∞–∫–≤–∏

**b) –†–∞–∑—Å—Ç–æ—è–Ω–∏–µ –º–µ–∂–¥—É –≥—Ä–∞–¥–æ–≤–µ:**
- **–ù–µ–Ω–∞—Å–æ—á–µ–Ω** - –ø—ä—Ç—è—Ç –æ—Ç A –¥–æ B –µ —Å—ä—â–∏—è—Ç –∫–∞—Ç–æ –æ—Ç B –¥–æ A
- **–ü—Ä–µ—Ç–µ–≥–ª–µ–Ω** - –≤—Å—è–∫–æ —Ä–µ–±—Ä–æ –∏–º–∞ —Ç–µ–≥–ª–æ (—Ä–∞–∑—Å—Ç–æ—è–Ω–∏–µ –≤ –∫–º)

**c) Facebook –ø—Ä–∏—è—Ç–µ–ª—Å—Ç–≤–∞:**
- **–ù–µ–Ω–∞—Å–æ—á–µ–Ω** - –ø—Ä–∏—è—Ç–µ–ª—Å—Ç–≤–æ—Ç–æ –µ –¥–≤—É—Å—Ç—Ä–∞–Ω–Ω–æ
- **–ù–µ–ø—Ä–µ—Ç–µ–≥–ª–µ–Ω** - –≤—Å–∏—á–∫–∏ –ø—Ä–∏—è—Ç–µ–ª—Å—Ç–≤–∞ —Å–∞ —Ä–∞–≤–Ω–æ—Å—Ç–æ–π–Ω–∏

**d) –ï–¥–Ω–æ–ø–æ—Å–æ—á–Ω–∏ —É–ª–∏—Ü–∏ —Å –≤—Ä–µ–º–µ–Ω–∞ –∑–∞ –∑–∞–¥—Ä—ä—Å—Ç–≤–∞–Ω–µ:**
- **–ù–∞—Å–æ—á–µ–Ω** - —É–ª–∏—Ü–∏—Ç–µ —Å–∞ –µ–¥–Ω–æ–ø–æ—Å–æ—á–Ω–∏
- **–ü—Ä–µ—Ç–µ–≥–ª–µ–Ω** - —Ç–µ–≥–ª–æ—Ç–æ –µ –≤—Ä–µ–º–µ—Ç–æ –∑–∞ –∑–∞–¥—Ä—ä—Å—Ç–≤–∞–Ω–µ

</CollapsibleSection>

---

<ExerciseCard
  difficulty="easy"
  timeEstimate="15 min"
  tags={["adjacency-matrix", "graph-representation"]}
>

### –ß–µ—Ç–µ–Ω–µ –Ω–∞ –ú–∞—Ç—Ä–∏—Ü–∞ –Ω–∞ –°—ä—Å–µ–¥—Å—Ç–≤–æ

–î–∞–¥–µ–Ω–∞ –µ —Ç–∞–∑–∏ –º–∞—Ç—Ä–∏—Ü–∞ –Ω–∞ —Å—ä—Å–µ–¥—Å—Ç–≤–æ –∑–∞ –Ω–µ–Ω–∞—Å–æ—á–µ–Ω –≥—Ä–∞—Ñ —Å –≤—ä—Ä—Ö–æ–≤–µ \{0, 1, 2, 3\}:

```
  0 1 2 3
0 0 1 1 0
1 1 0 0 1
2 1 0 0 1
3 0 1 1 0
```

**a)** –ò–∑–±—Ä–æ–µ—Ç–µ –≤—Å–∏—á–∫–∏ —Ä–µ–±—Ä–∞ –≤ –≥—Ä–∞—Ñ–∞

**b)** –ö–∞–∫–≤–∞ –µ —Å—Ç–µ–ø–µ–Ω—Ç–∞ –Ω–∞ –≤—Ä—ä—Ö 1?

**c)** –ö–æ–∏ –≤—ä—Ä—Ö–æ–≤–µ —Å–∞ —Å—ä—Å–µ–¥–Ω–∏ –Ω–∞ –≤—Ä—ä—Ö 2?

</ExerciseCard>

<CollapsibleSection title="‚úÖ –†–µ—à–µ–Ω–∏–µ" icon="‚úÖ">

**a) –í—Å–∏—á–∫–∏ —Ä–µ–±—Ä–∞:**
- (0, 1)
- (0, 2)
- (1, 3)
- (2, 3)

–ó–∞–±–µ–ª–µ–∂–∫–∞: –¢—ä–π –∫–∞—Ç–æ –≥—Ä–∞—Ñ—ä—Ç –µ –Ω–µ–Ω–∞—Å–æ—á–µ–Ω, (0,1) –∏ (1,0) —Å–∞ –µ–¥–Ω–æ –∏ —Å—ä—â–æ —Ä–µ–±—Ä–æ.

**b) –°—Ç–µ–ø–µ–Ω –Ω–∞ –≤—Ä—ä—Ö 1:**
–í—Ä—ä—Ö 1 –µ —Å–≤—ä—Ä–∑–∞–Ω —Å –≤—ä—Ä—Ö–æ–≤–µ 0 –∏ 3, —Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª–Ω–æ —Å—Ç–µ–ø–µ–Ω—Ç–∞ –µ **2**.

**c) –°—ä—Å–µ–¥–∏ –Ω–∞ –≤—Ä—ä—Ö 2:**
–í—Ä—ä—Ö 2 –µ —Å—ä—Å–µ–¥–µ–Ω –Ω–∞ –≤—ä—Ä—Ö–æ–≤–µ **0 –∏ 3**.

</CollapsibleSection>

---

<ExerciseCard
  difficulty="easy"
  timeEstimate="10 min"
  tags={["cpp", "stl", "containers"]}
>

### –ò–∑–±–æ—Ä –Ω–∞ STL –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä

–°—ä–ø–æ—Å—Ç–∞–≤–µ—Ç–µ –≤—Å–µ–∫–∏ C++ STL –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä —Å –Ω–∞–π-–ø–æ–¥—Ö–æ–¥—è—â–∏—è –º—É —Å–ª—É—á–∞–π –Ω–∞ –∏–∑–ø–æ–ª–∑–≤–∞–Ω–µ –ø—Ä–∏ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏—è –Ω–∞ –≥—Ä–∞—Ñ–∏:

**–ö–æ–Ω—Ç–µ–π–Ω–µ—Ä–∏:**
- `vector<vector<int>>`
- `map<int, list<int>>`
- `unordered_set<int>`
- `priority_queue<pair<int,int>>`

**–°–ª—É—á–∞–∏ –Ω–∞ –∏–∑–ø–æ–ª–∑–≤–∞–Ω–µ:**
- A) –°—ä—Ö—Ä–∞–Ω—è–≤–∞–Ω–µ –Ω–∞ –ø–æ—Å–µ—Ç–µ–Ω–∏ –≤—ä—Ä—Ö–æ–≤–µ –ø—Ä–∏ –æ–±—Ö–æ–∂–¥–∞–Ω–µ
- B) –ú–∞—Ç—Ä–∏—Ü–∞ –Ω–∞ —Å—ä—Å–µ–¥—Å—Ç–≤–æ –∑–∞ –º–∞–ª–∫–∏ –≥—Ä–∞—Ñ–∏
- C) –°–ø–∏—Å—ä–∫ –Ω–∞ —Å—ä—Å–µ–¥—Å—Ç–≤–æ —Å –≥—ä–≤–∫–∞–≤–∏ ID-—Ç–∞ –Ω–∞ –≤—ä—Ä—Ö–æ–≤–µ—Ç–µ
- D) –ò–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏—è –Ω–∞ –∞–ª–≥–æ—Ä–∏—Ç—ä–º–∞ –Ω–∞ Dijkstra

</ExerciseCard>

<CollapsibleSection title="‚úÖ –†–µ—à–µ–Ω–∏–µ" icon="‚úÖ">

**–°—ä–ø–æ—Å—Ç–∞–≤—è–Ω–µ:**

- `vector<vector<int>>` ‚Üí **B)** –ú–∞—Ç—Ä–∏—Ü–∞ –Ω–∞ —Å—ä—Å–µ–¥—Å—Ç–≤–æ –∑–∞ –º–∞–ª–∫–∏ –≥—Ä–∞—Ñ–∏
- `map<int, list<int>>` ‚Üí **C)** –°–ø–∏—Å—ä–∫ –Ω–∞ —Å—ä—Å–µ–¥—Å—Ç–≤–æ —Å –≥—ä–≤–∫–∞–≤–∏ ID-—Ç–∞ –Ω–∞ –≤—ä—Ä—Ö–æ–≤–µ—Ç–µ
- `unordered_set<int>` ‚Üí **A)** –°—ä—Ö—Ä–∞–Ω—è–≤–∞–Ω–µ –Ω–∞ –ø–æ—Å–µ—Ç–µ–Ω–∏ –≤—ä—Ä—Ö–æ–≤–µ –ø—Ä–∏ –æ–±—Ö–æ–∂–¥–∞–Ω–µ
- `priority_queue<pair<int,int>>` ‚Üí **D)** –ò–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏—è –Ω–∞ –∞–ª–≥–æ—Ä–∏—Ç—ä–º–∞ –Ω–∞ Dijkstra

</CollapsibleSection>

---

<ExerciseCard
  difficulty="easy"
  timeEstimate="15 min"
  tags={["complexity", "space-analysis"]}
>

### –ê–Ω–∞–ª–∏–∑ –Ω–∞ –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–∞ –°–ª–æ–∂–Ω–æ—Å—Ç

–ï–¥–∏–Ω –≥—Ä–∞—Ñ –∏–º–∞ 100 –≤—ä—Ä—Ö–∞ –∏ 200 —Ä–µ–±—Ä–∞.

**a)** –ö–æ–ª–∫–æ –ø–∞–º–µ—Ç (–≤ –±—Ä–æ–π integer –∫–ª–µ—Ç–∫–∏) –∏–∑–ø–æ–ª–∑–≤–∞ –º–∞—Ç—Ä–∏—Ü–∞ –Ω–∞ —Å—ä—Å–µ–¥—Å—Ç–≤–æ?

**b)** –ö–æ–ª–∫–æ –ø–∞–º–µ—Ç –∏–∑–ø–æ–ª–∑–≤–∞ —Å–ø–∏—Å—ä–∫ –Ω–∞ —Å—ä—Å–µ–¥—Å—Ç–≤–æ?

**c)** –ö–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤—è–Ω–µ –µ –ø–æ-–µ—Ñ–µ–∫—Ç–∏–≤–Ω–æ –ø–æ –ø–∞–º–µ—Ç –∑–∞ —Ç–æ–∑–∏ –≥—Ä–∞—Ñ?

</ExerciseCard>

<CollapsibleSection title="‚úÖ –†–µ—à–µ–Ω–∏–µ" icon="‚úÖ">

**a) –ú–∞—Ç—Ä–∏—Ü–∞ –Ω–∞ —Å—ä—Å–µ–¥—Å—Ç–≤–æ:**
- –†–∞–∑–º–µ—Ä: V √ó V = 100 √ó 100 = **10,000 integer –∫–ª–µ—Ç–∫–∏**

**b) –°–ø–∏—Å—ä–∫ –Ω–∞ —Å—ä—Å–µ–¥—Å—Ç–≤–æ:**
- –ó–∞ –Ω–µ–Ω–∞—Å–æ—á–µ–Ω –≥—Ä–∞—Ñ: 2E –∑–∞–ø–∏—Å–∞ (–≤—Å—è–∫–æ —Ä–µ–±—Ä–æ —Å–µ —Å—ä—Ö—Ä–∞–Ω—è–≤–∞ –¥–≤—É–ø–æ—Å–æ—á–Ω–æ)
- –ü–∞–º–µ—Ç: V (–∑–∞ –º–∞—Å–∏–≤–∞) + 2E (–∑–∞ —Å–ø–∏—Å—ä—Ü–∏—Ç–µ) = 100 + 2(200) = **500 integer –∫–ª–µ—Ç–∫–∏**

**c) –ü–æ-–µ—Ñ–µ–∫—Ç–∏–≤–Ω–æ –ø—Ä–µ–¥—Å—Ç–∞–≤—è–Ω–µ:**
- **–°–ø–∏—Å—ä–∫ –Ω–∞ —Å—ä—Å–µ–¥—Å—Ç–≤–æ** –µ –º–Ω–æ–≥–æ –ø–æ-–µ—Ñ–µ–∫—Ç–∏–≤–µ–Ω: 500 vs 10,000 –∫–ª–µ—Ç–∫–∏
- –ì—Ä–∞—Ñ—ä—Ç –µ —Ä–∞–∑—Ä–µ–¥–µ–Ω (200 —Ä–µ–±—Ä–∞ –æ—Ç –≤—ä–∑–º–æ–∂–Ω–∏—Ç–µ 4,950), –∫–æ–µ—Ç–æ –ø—Ä–∞–≤–∏ —Å–ø–∏—Å—ä–∫–∞ –Ω–∞ —Å—ä—Å–µ–¥—Å—Ç–≤–æ –∏–¥–µ–∞–ª–µ–Ω –∏–∑–±–æ—Ä

</CollapsibleSection>

---

## –ò–∑–≥—Ä–∞–∂–¥–∞–Ω–µ –Ω–∞ –†–∞–∑–±–∏—Ä–∞–Ω–µ (EASY-MEDIUM)

<ExerciseCard
  difficulty="easy"
  timeEstimate="10 min"
  tags={["code-reading", "adjacency-list"]}
>

### –ß–µ—Ç–µ–Ω–µ –Ω–∞ –ö–æ–¥ - –°–ø–∏—Å—ä–∫ –Ω–∞ –°—ä—Å–µ–¥—Å—Ç–≤–æ

–ö–∞–∫–≤–æ –∏–∑–≤–µ–∂–¥–∞ —Ç–æ–∑–∏ –∫–æ–¥?

```cpp
map<int, list<int>> adj;
adj[1] = {2, 3};
adj[2] = {1, 4};
adj[3] = {1};
adj[4] = {2};

for (int n : adj[2]) {
    cout << n << " ";
}
```

</ExerciseCard>

<CollapsibleSection title="‚úÖ –†–µ—à–µ–Ω–∏–µ" icon="‚úÖ">

**–ò–∑—Ö–æ–¥:** `1 4 `

–û–±—è—Å–Ω–µ–Ω–∏–µ: –ö–æ–¥—ä—Ç –æ–±—Ö–æ–∂–¥–∞ —Å–ø–∏—Å—ä–∫–∞ –Ω–∞ —Å—ä—Å–µ–¥—Å—Ç–≤–æ –∑–∞ –≤—Ä—ä—Ö 2, –∫–æ–π—Ç–æ —Å—ä–¥—ä—Ä–∂–∞ –≤—ä—Ä—Ö–æ–≤–µ 1 –∏ 4.

</CollapsibleSection>

---

<ExerciseCard
  difficulty="easy"
  timeEstimate="20 min"
  tags={["implementation", "adjacency-matrix"]}
>

### –°—ä–∑–¥–∞–≤–∞–Ω–µ –Ω–∞ –ú–∞—Ç—Ä–∏—Ü–∞ –Ω–∞ –°—ä—Å–µ–¥—Å—Ç–≤–æ

–ù–∞–ø–∏—à–µ—Ç–µ C++ –∫–æ–¥ –∑–∞ —Å—ä–∑–¥–∞–≤–∞–Ω–µ –Ω–∞ –º–∞—Ç—Ä–∏—Ü–∞ –Ω–∞ —Å—ä—Å–µ–¥—Å—Ç–≤–æ –∑–∞ –Ω–∞—Å–æ—á–µ–Ω –≥—Ä–∞—Ñ —Å 4 –≤—ä—Ä—Ö–∞ –∏ —Å–ª–µ–¥–Ω–∏—Ç–µ —Ä–µ–±—Ä–∞: (0‚Üí1), (0‚Üí2), (1‚Üí2), (2‚Üí3), (3‚Üí1)

</ExerciseCard>

<CollapsibleSection title="‚úÖ –†–µ—à–µ–Ω–∏–µ" icon="‚úÖ">

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int n = 4; // –ë—Ä–æ–π –≤—ä—Ä—Ö–æ–≤–µ
    vector<vector<int>> adjMatrix(n, vector<int>(n, 0));

    // –î–æ–±–∞–≤—è–Ω–µ –Ω–∞ —Ä–µ–±—Ä–∞—Ç–∞ (u -> v)
    adjMatrix[0][1] = 1; // 0 -> 1
    adjMatrix[0][2] = 1; // 0 -> 2
    adjMatrix[1][2] = 1; // 1 -> 2
    adjMatrix[2][3] = 1; // 2 -> 3
    adjMatrix[3][1] = 1; // 3 -> 1

    // –ò–∑–≤–µ–∂–¥–∞–Ω–µ –Ω–∞ –º–∞—Ç—Ä–∏—Ü–∞—Ç–∞
    cout << "–ú–∞—Ç—Ä–∏—Ü–∞ –Ω–∞ —Å—ä—Å–µ–¥—Å—Ç–≤–æ:" << endl;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cout << adjMatrix[i][j] << " ";
        }
        cout << endl;
    }

    return 0;
}
```

**–ò–∑—Ö–æ–¥:**
```
–ú–∞—Ç—Ä–∏—Ü–∞ –Ω–∞ —Å—ä—Å–µ–¥—Å—Ç–≤–æ:
0 1 1 0
0 0 1 0
0 0 0 1
0 1 0 0
```

</CollapsibleSection>

---

<ExerciseCard
  difficulty="medium"
  timeEstimate="20 min"
  tags={["implementation", "weighted-graph"]}
>

### –î–æ–ø—ä–ª–≤–∞–Ω–µ –Ω–∞ –ò–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏—è—Ç–∞

–ü–æ–ø—ä–ª–Ω–µ—Ç–µ –ª–∏–ø—Å–≤–∞—â–∏—è –∫–æ–¥ –∑–∞ –¥–æ–±–∞–≤—è–Ω–µ –Ω–∞ —Ä–µ–±—Ä–æ –≤ —Å–ø–∏—Å—ä–∫ –Ω–∞ —Å—ä—Å–µ–¥—Å—Ç–≤–æ –∑–∞ –ø—Ä–µ—Ç–µ–≥–ª–µ–Ω, –Ω–µ–Ω–∞—Å–æ—á–µ–Ω –≥—Ä–∞—Ñ:

```cpp
class WeightedGraph {
    map<int, list<pair<int, int>>> adj; // vertex -> {neighbor, weight}
public:
    void addEdge(int u, int v, int weight) {
        // YOUR CODE HERE
    }
};
```

</ExerciseCard>

<CollapsibleSection title="‚úÖ –†–µ—à–µ–Ω–∏–µ" icon="‚úÖ">

```cpp
class WeightedGraph {
    map<int, list<pair<int, int>>> adj; // vertex -> {neighbor, weight}
public:
    void addEdge(int u, int v, int weight) {
        // –î–æ–±–∞–≤—è–º–µ —Ä–µ–±—Ä–æ –æ—Ç u –∫—ä–º v —Å —Ç–µ–≥–ª–æ weight
        adj[u].push_back({v, weight});

        // –ó–∞ –Ω–µ–Ω–∞—Å–æ—á–µ–Ω –≥—Ä–∞—Ñ –¥–æ–±–∞–≤—è–º–µ –∏ –æ–±—Ä–∞—Ç–Ω–æ—Ç–æ —Ä–µ–±—Ä–æ
        adj[v].push_back({u, weight});
    }

    // –ü–æ–º–æ—â–Ω–∞ —Ñ—É–Ω–∫—Ü–∏—è –∑–∞ –∏–∑–≤–µ–∂–¥–∞–Ω–µ
    void printGraph() {
        for (auto& [vertex, neighbors] : adj) {
            cout << vertex << ": ";
            for (auto& [neighbor, weight] : neighbors) {
                cout << "(" << neighbor << "," << weight << ") ";
            }
            cout << endl;
        }
    }
};
```

**–ü—Ä–∏–º–µ—Ä –∑–∞ –∏–∑–ø–æ–ª–∑–≤–∞–Ω–µ:**
```cpp
WeightedGraph g;
g.addEdge(0, 1, 5);
g.addEdge(1, 2, 3);
g.addEdge(0, 2, 7);
g.printGraph();
```

</CollapsibleSection>

---

<ExerciseCard
  difficulty="medium"
  timeEstimate="25 min"
  tags={["bfs", "trace", "algorithm"]}
>

### –ü—Ä–æ—Å–ª–µ–¥—è–≤–∞–Ω–µ –Ω–∞ BFS

–î–∞–¥–µ–Ω –µ —Ç–æ–∑–∏ –≥—Ä–∞—Ñ, –ø—Ä–µ–¥—Å—Ç–∞–≤–µ–Ω –∫–∞—Ç–æ —Å–ø–∏—Å—ä–∫ –Ω–∞ —Å—ä—Å–µ–¥—Å—Ç–≤–æ:
```
0: [1, 2]
1: [0, 3, 4]
2: [0, 4]
3: [1]
4: [1, 2]
```

–ü—Ä–æ—Å–ª–µ–¥–µ—Ç–µ –∞–ª–≥–æ—Ä–∏—Ç—ä–º–∞ BFS, –∑–∞–ø–æ—á–≤–∞–π–∫–∏ –æ—Ç –≤—Ä—ä—Ö 0. –ü–æ–∫–∞–∂–µ—Ç–µ:

**a)** –†–µ–¥—ä—Ç, –≤ –∫–æ–π—Ç–æ –≤—ä—Ä—Ö–æ–≤–µ—Ç–µ —Å–µ –ø–æ—Å–µ—â–∞–≤–∞—Ç

**b)** –°—ä–¥—ä—Ä–∂–∞–Ω–∏–µ—Ç–æ –Ω–∞ –æ–ø–∞—à–∫–∞—Ç–∞ —Å–ª–µ–¥ –≤—Å—è–∫–∞ dequeue –æ–ø–µ—Ä–∞—Ü–∏—è

**c)** BFS –¥—ä—Ä–≤–æ—Ç–æ (parent –≤—Ä—ä–∑–∫–∏)

</ExerciseCard>

<CollapsibleSection title="‚úÖ –†–µ—à–µ–Ω–∏–µ" icon="‚úÖ">

**a) –†–µ–¥ –Ω–∞ –ø–æ—Å–µ—â–µ–Ω–∏–µ:** 0, 1, 2, 3, 4

**b) –°—ä—Å—Ç–æ—è–Ω–∏–µ –Ω–∞ –æ–ø–∞—à–∫–∞—Ç–∞:**

| –°—Ç—ä–ø–∫–∞ | Dequeue | Enqueue | –û–ø–∞—à–∫–∞ —Å–ª–µ–¥ dequeue |
|--------|---------|---------|---------------------|
| 1      | 0       | 1, 2    | [1, 2]              |
| 2      | 1       | 3, 4    | [2, 3, 4]           |
| 3      | 2       | -       | [3, 4]              |
| 4      | 3       | -       | [4]                 |
| 5      | 4       | -       | []                  |

**c) BFS –¥—ä—Ä–≤–æ (parent –≤—Ä—ä–∑–∫–∏):**
```
0 (root)
‚îú‚îÄ‚îÄ 1 (parent: 0)
‚îÇ   ‚îú‚îÄ‚îÄ 3 (parent: 1)
‚îÇ   ‚îî‚îÄ‚îÄ 4 (parent: 1)
‚îî‚îÄ‚îÄ 2 (parent: 0)
```

</CollapsibleSection>

---

<ExerciseCard
  difficulty="medium"
  timeEstimate="25 min"
  tags={["dfs", "bfs", "comparison"]}
>

### DFS vs BFS

–ó–∞ —Å—ä—â–∏—è –≥—Ä–∞—Ñ –æ—Ç –ó–∞–¥–∞—á–∞ 9:

**a)** –ü—Ä–æ—Å–ª–µ–¥–µ—Ç–µ DFS, –∑–∞–ø–æ—á–≤–∞–π–∫–∏ –æ—Ç –≤—Ä—ä—Ö 0 (–ø—Ä–∏–µ–º–∞–º–µ, —á–µ —Å—ä—Å–µ–¥–∏—Ç–µ —Å–µ –ø–æ—Å–µ—â–∞–≤–∞—Ç –≤—ä–≤ –≤—ä–∑—Ö–æ–¥—è—â —Ä–µ–¥)

**b)** –°—Ä–∞–≤–Ω–µ—Ç–µ —Ä–µ–¥–∞ –Ω–∞ –ø–æ—Å–µ—â–µ–Ω–∏–µ —Å BFS

**c)** –û–±—è—Å–Ω–µ—Ç–µ –∑–∞—â–æ —Ä–µ–¥–æ–≤–µ—Ç–µ —Å–µ —Ä–∞–∑–ª–∏—á–∞–≤–∞—Ç

</ExerciseCard>

<CollapsibleSection title="‚úÖ –†–µ—à–µ–Ω–∏–µ" icon="‚úÖ">

**a) DFS –æ–±—Ö–æ–∂–¥–∞–Ω–µ –æ—Ç –≤—Ä—ä—Ö 0:**

–†–µ–¥ –Ω–∞ –ø–æ—Å–µ—â–µ–Ω–∏–µ: **0, 1, 3, 4, 2**

Trace:
```
DFS(0) -> visited: {0}
  DFS(1) -> visited: {0, 1}
    DFS(3) -> visited: {0, 1, 3}
    DFS(4) -> visited: {0, 1, 3, 4}
      (2 –≤–µ—á–µ –ø–æ—Å–µ—Ç–µ–Ω –æ—Ç 4? –ù–µ)
      DFS(2) -> visited: {0, 1, 3, 4, 2}
```

**b) –°—Ä–∞–≤–Ω–µ–Ω–∏–µ:**
- **BFS:** 0, 1, 2, 3, 4 (–Ω–∏–≤–æ –ø–æ –Ω–∏–≤–æ)
- **DFS:** 0, 1, 3, 4, 2 (–≤ –¥—ä–ª–±–æ—á–∏–Ω–∞)

**c) –ó–∞—â–æ —Å–µ —Ä–∞–∑–ª–∏—á–∞–≤–∞—Ç:**

- **BFS** –∏–∑–ø–æ–ª–∑–≤–∞ –æ–ø–∞—à–∫–∞ (FIFO) –∏ –∏–∑—Å–ª–µ–¥–≤–∞ –≤—Å–∏—á–∫–∏ —Å—ä—Å–µ–¥–∏ –Ω–∞ —Ç–µ–∫—É—â–æ—Ç–æ –Ω–∏–≤–æ –ø—Ä–µ–¥–∏ –¥–∞ –ø—Ä–æ–¥—ä–ª–∂–∏ –∫—ä–º —Å–ª–µ–¥–≤–∞—â–æ—Ç–æ –Ω–∏–≤–æ
- **DFS** –∏–∑–ø–æ–ª–∑–≤–∞ —Å—Ç–µ–∫/—Ä–µ–∫—É—Ä—Å–∏—è (LIFO) –∏ –æ—Ç–∏–≤–∞ –∫–æ–ª–∫–æ—Ç–æ –µ –≤—ä–∑–º–æ–∂–Ω–æ –ø–æ-–¥—ä–ª–±–æ–∫–æ –ø–æ –µ–¥–∏–Ω –ø—ä—Ç –ø—Ä–µ–¥–∏ –¥–∞ —Å–µ –≤—ä—Ä–Ω–µ –Ω–∞–∑–∞–¥
- –í —Ç–æ–∑–∏ –ø—Ä–∏–º–µ—Ä, BFS –ø–æ—Å–µ—â–∞–≤–∞ –≤—Ä—ä—Ö 2 –≤–µ–¥–Ω–∞–≥–∞ —Å–ª–µ–¥ 1 (–∑–∞—â–æ—Ç–æ —Å–∞ –Ω–∞ —Å—ä—â–æ—Ç–æ –Ω–∏–≤–æ), –¥–æ–∫–∞—Ç–æ DFS –ø—Ä–æ–¥—ä–ª–∂–∞–≤–∞ –≤ –¥—ä–ª–±–æ—á–∏–Ω–∞ –ø—Ä–µ–∑ 1‚Üí3‚Üí4 –ø—Ä–µ–¥–∏ –¥–∞ –¥–æ—Å—Ç–∏–≥–Ω–µ 2

</CollapsibleSection>

---

## –ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –∏ –ê–Ω–∞–ª–∏–∑ (MEDIUM)

<ExerciseCard
  difficulty="medium"
  timeEstimate="20 min"
  tags={["graph-representation", "analysis"]}
>

### –ò–∑–±–æ—Ä –Ω–∞ –ü—Ä–µ–¥—Å—Ç–∞–≤—è–Ω–µ

–ó–∞ –≤—Å–µ–∫–∏ —Å—Ü–µ–Ω–∞—Ä–∏–π –∏–∑–±–µ—Ä–µ—Ç–µ –Ω–∞–π-–¥–æ–±—Ä–æ—Ç–æ –ø—Ä–µ–¥—Å—Ç–∞–≤—è–Ω–µ –Ω–∞ –≥—Ä–∞—Ñ–∞ (–º–∞—Ç—Ä–∏—Ü–∞ –∏–ª–∏ —Å–ø–∏—Å—ä–∫ –Ω–∞ —Å—ä—Å–µ–¥—Å—Ç–≤–æ) –∏ –æ–±–æ—Å–Ω–æ–≤–µ—Ç–µ –∏–∑–±–æ—Ä–∞ —Å–∏:

**a)** –ü—ä–ª–µ–Ω –≥—Ä–∞—Ñ —Å 50 –≤—ä—Ä—Ö–∞ (–≤—Å—è–∫–∞ –¥–≤–æ–π–∫–∞ –µ —Å–≤—ä—Ä–∑–∞–Ω–∞)

**b)** –°–æ—Ü–∏–∞–ª–Ω–∞ –º—Ä–µ–∂–∞ —Å 1 –º–∏–ª–∏–æ–Ω –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–∏, –∫—ä–¥–µ—Ç–æ –≤—Å–µ–∫–∏ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª –∏–º–∞ —Å—Ä–µ–¥–Ω–æ 200 –ø—Ä–∏—è—Ç–µ–ª–∏

**c)** –ú–∞–ª–∫–∞ –∏–≥—Ä–∞–ª–Ω–∞ –¥—ä—Å–∫–∞ (10√ó10), –∫—ä–¥–µ—Ç–æ –≤—Å—è–∫–∞ –∫–ª–µ—Ç–∫–∞ —Å–µ —Å–≤—ä—Ä–∑–≤–∞ —Å—ä—Å —Å—ä—Å–µ–¥–Ω–∏—Ç–µ –∫–ª–µ—Ç–∫–∏

**d)** –†–∞–∑—Ä–µ–¥–µ–Ω–∞ –º—Ä–µ–∂–∞ –æ—Ç —Ü–∏—Ç–∏—Ä–∞–Ω–∏—è —Å 10,000 —Å—Ç–∞—Ç–∏–∏ –∏ 15,000 —Ü–∏—Ç–∏—Ä–∞–Ω–∏—è

</ExerciseCard>

<CollapsibleSection title="‚úÖ –†–µ—à–µ–Ω–∏–µ" icon="‚úÖ">

**a) –ü—ä–ª–µ–Ω –≥—Ä–∞—Ñ —Å 50 –≤—ä—Ä—Ö–∞:**
- **–ò–∑–±–æ—Ä: –ú–∞—Ç—Ä–∏—Ü–∞ –Ω–∞ —Å—ä—Å–µ–¥—Å—Ç–≤–æ**
- **–û–±–æ—Å–Ω–æ–≤–∫–∞:** –í –ø—ä–ª–µ–Ω –≥—Ä–∞—Ñ –ø–æ—á—Ç–∏ –≤—Å–∏—á–∫–∏ –∫–ª–µ—Ç–∫–∏ –≤ –º–∞—Ç—Ä–∏—Ü–∞—Ç–∞ —â–µ –±—ä–¥–∞—Ç 1 (E = V(V-1)/2 ‚âà 1,225). –ù—è–º–∞ –∑–∞–≥—É–±–∞ –Ω–∞ –ø–∞–º–µ—Ç –∏ O(1) –ø—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞ —Ä–µ–±—Ä–æ –µ –ø–æ–ª–µ–∑–Ω–∞.

**b) –°–æ—Ü–∏–∞–ª–Ω–∞ –º—Ä–µ–∂–∞ —Å 1M –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–∏, 200 –ø—Ä–∏—è—Ç–µ–ª–∏ —Å—Ä–µ–¥–Ω–æ:**
- **–ò–∑–±–æ—Ä: –°–ø–∏—Å—ä–∫ –Ω–∞ —Å—ä—Å–µ–¥—Å—Ç–≤–æ**
- **–û–±–æ—Å–Ω–æ–≤–∫–∞:** E = 1M √ó 200 / 2 = 100M —Ä–µ–±—Ä–∞, –Ω–æ –º–∞—Ç—Ä–∏—Ü–∞ –±–∏ –∏–∑–∏—Å–∫–≤–∞–ª–∞ 1M √ó 1M = 1 —Ç—Ä–∏–ª–∏–æ–Ω –∫–ª–µ—Ç–∫–∏! –°–ø–∏—Å—ä–∫—ä—Ç –∏–∑–ø–æ–ª–∑–≤–∞ —Å–∞–º–æ O(V + E) = 101M –ø–∞–º–µ—Ç.

**c) –ò–≥—Ä–∞–ª–Ω–∞ –¥—ä—Å–∫–∞ 10√ó10:**
- **–ò–∑–±–æ—Ä: –ú–∞—Ç—Ä–∏—Ü–∞ –Ω–∞ —Å—ä—Å–µ–¥—Å—Ç–≤–æ**
- **–û–±–æ—Å–Ω–æ–≤–∫–∞:** –ú–∞–ª—ä–∫ –≥—Ä–∞—Ñ (100 –≤—ä—Ä—Ö–∞), –ø–ª—ä—Ç–µ–Ω (–≤—Å—è–∫–∞ –∫–ª–µ—Ç–∫–∞ –∏–º–∞ 2-4 —Å—ä—Å–µ–¥–∞), –º–∞—Ç—Ä–∏—Ü–∞ 100√ó100 = 10,000 –∫–ª–µ—Ç–∫–∏ –µ –ø—Ä–∏–µ–º–ª–∏–≤–æ.

**d) –ú—Ä–µ–∂–∞ –æ—Ç —Ü–∏—Ç–∏—Ä–∞–Ω–∏—è 10K —Å—Ç–∞—Ç–∏–∏, 15K —Ü–∏—Ç–∏—Ä–∞–Ω–∏—è:**
- **–ò–∑–±–æ—Ä: –°–ø–∏—Å—ä–∫ –Ω–∞ —Å—ä—Å–µ–¥—Å—Ç–≤–æ**
- **–û–±–æ—Å–Ω–æ–≤–∫–∞:** –†–∞–∑—Ä–µ–¥–µ–Ω –≥—Ä–∞—Ñ (E &lt;&lt; V¬≤). –ú–∞—Ç—Ä–∏—Ü–∞ –±–∏ –∏–∑–∏—Å–∫–≤–∞–ª–∞ 100M –∫–ª–µ—Ç–∫–∏, –¥–æ–∫–∞—Ç–æ —Å–ø–∏—Å—ä–∫—ä—Ç –∏–∑–∏—Å–∫–≤–∞ —Å–∞–º–æ 25K.

</CollapsibleSection>

---

<ExerciseCard
  difficulty="medium"
  timeEstimate="15 min"
  tags={["debugging", "bfs"]}
>

### –¢—ä—Ä—Å–µ–Ω–µ –Ω–∞ –ë—ä–≥

–ù–∞–º–µ—Ä–µ—Ç–µ –∏ –∫–æ—Ä–∏–≥–∏—Ä–∞–π—Ç–µ –±—ä–≥–∞ –≤ —Ç–∞–∑–∏ BFS –∏–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏—è:

```cpp
void BFS(const map<int, list<int>>& graph, int start) {
    queue<int> q;
    unordered_set<int> visited;
    q.push(start);

    while (!q.empty()) {
        int v = q.front(); q.pop();
        visited.insert(v);
        cout << v << " ";

        for (int nbr : graph.at(v)) {
            if (!visited.count(nbr)) {
                q.push(nbr);
            }
        }
    }
}
```

</ExerciseCard>

<CollapsibleSection title="‚úÖ –†–µ—à–µ–Ω–∏–µ" icon="‚úÖ">

**–ü—Ä–æ–±–ª–µ–º:** –í—ä—Ä—Ö—ä—Ç —Å–µ –º–∞—Ä–∫–∏—Ä–∞ –∫–∞—Ç–æ –ø–æ—Å–µ—Ç–µ–Ω –°–õ–ï–î –∫–∞—Ç–æ —Å–µ –∏–∑–≤–∞–¥–∏ –æ—Ç –æ–ø–∞—à–∫–∞—Ç–∞, –∞ –Ω–µ –∫–æ–≥–∞—Ç–æ —Å–µ –¥–æ–±–∞–≤–∏. –¢–æ–≤–∞ –º–æ–∂–µ –¥–∞ –¥–æ–≤–µ–¥–µ –¥–æ –¥–æ–±–∞–≤—è–Ω–µ –Ω–∞ —Å—ä—â–∏—è –≤—Ä—ä—Ö –≤ –æ–ø–∞—à–∫–∞—Ç–∞ –º–Ω–æ–≥–æ–∫—Ä–∞—Ç–Ω–æ.

**–ö–æ—Ä–∏–≥–∏—Ä–∞–Ω –∫–æ–¥:**

```cpp
void BFS(const map<int, list<int>>& graph, int start) {
    queue<int> q;
    unordered_set<int> visited;

    // –ú–∞—Ä–∫–∏—Ä–∞–º–µ –Ω–∞—á–∞–ª–Ω–∏—è –≤—Ä—ä—Ö –∫–∞—Ç–æ –ø–æ—Å–µ—Ç–µ–Ω –ü–†–ï–î–ò –¥–∞ –≥–æ –¥–æ–±–∞–≤–∏–º –≤ –æ–ø–∞—à–∫–∞—Ç–∞
    visited.insert(start);
    q.push(start);

    while (!q.empty()) {
        int v = q.front(); q.pop();
        cout << v << " ";

        for (int nbr : graph.at(v)) {
            if (!visited.count(nbr)) {
                visited.insert(nbr); // –ú–∞—Ä–∫–∏—Ä–∞–º–µ –∫–∞—Ç–æ –ø–æ—Å–µ—Ç–µ–Ω –í–ï–î–ù–ê–ì–ê
                q.push(nbr);
            }
        }
    }
}
```

**–û–±—è—Å–Ω–µ–Ω–∏–µ –Ω–∞ –≥—Ä–µ—à–∫–∞—Ç–∞:**
–ê–∫–æ –Ω–µ –º–∞—Ä–∫–∏—Ä–∞–º–µ –≤—ä—Ä—Ö–∞ –∫–∞—Ç–æ –ø–æ—Å–µ—Ç–µ–Ω –ø—Ä–∏ –¥–æ–±–∞–≤—è–Ω–µ –≤ –æ–ø–∞—à–∫–∞—Ç–∞, —Ç–æ–π –º–æ–∂–µ –¥–∞ –±—ä–¥–µ –¥–æ–±–∞–≤–µ–Ω –º–Ω–æ–≥–æ–∫—Ä–∞—Ç–Ω–æ –æ—Ç —Ä–∞–∑–ª–∏—á–Ω–∏ —Å—ä—Å–µ–¥–∏, –ø—Ä–µ–¥–∏ –¥–∞ –±—ä–¥–µ –∏–∑–≤–ª–µ—á–µ–Ω –∏ –º–∞—Ä–∫–∏—Ä–∞–Ω.

</CollapsibleSection>

---

<ExerciseCard
  difficulty="medium"
  timeEstimate="25 min"
  tags={["implementation", "complexity"]}
>

### –ò–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏—è –Ω–∞ –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞ –†–µ–±—Ä–æ

–ò–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞–π—Ç–µ —Ñ—É–Ω–∫—Ü–∏—è `bool hasEdge(int u, int v)` –∫–∞–∫—Ç–æ –∑–∞ –º–∞—Ç—Ä–∏—Ü–∞ –Ω–∞ —Å—ä—Å–µ–¥—Å—Ç–≤–æ, —Ç–∞–∫–∞ –∏ –∑–∞ —Å–ø–∏—Å—ä–∫ –Ω–∞ —Å—ä—Å–µ–¥—Å—Ç–≤–æ. –°—Ä–∞–≤–Ω–µ—Ç–µ —Ç–µ—Ö–Ω–∏—Ç–µ –≤—Ä–µ–º–µ–≤–∏ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏.

```cpp
// –ó–∞ –º–∞—Ç—Ä–∏—Ü–∞ –Ω–∞ —Å—ä—Å–µ–¥—Å—Ç–≤–æ
class MatrixGraph {
    vector<vector<int>> adj;
public:
    bool hasEdge(int u, int v) {
        // YOUR CODE HERE
    }
};

// –ó–∞ —Å–ø–∏—Å—ä–∫ –Ω–∞ —Å—ä—Å–µ–¥—Å—Ç–≤–æ
class ListGraph {
    map<int, list<int>> adj;
public:
    bool hasEdge(int u, int v) {
        // YOUR CODE HERE
    }
};
```

</ExerciseCard>

<CollapsibleSection title="‚úÖ –†–µ—à–µ–Ω–∏–µ" icon="‚úÖ">

```cpp
#include <vector>
#include <map>
#include <list>
#include <algorithm>
using namespace std;

// –ó–∞ –º–∞—Ç—Ä–∏—Ü–∞ –Ω–∞ —Å—ä—Å–µ–¥—Å—Ç–≤–æ
class MatrixGraph {
    vector<vector<int>> adj;
    int n;
public:
    MatrixGraph(int vertices) : n(vertices) {
        adj.resize(n, vector<int>(n, 0));
    }

    void addEdge(int u, int v) {
        adj[u][v] = 1;
        adj[v][u] = 1; // –ó–∞ –Ω–µ–Ω–∞—Å–æ—á–µ–Ω –≥—Ä–∞—Ñ
    }

    bool hasEdge(int u, int v) {
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞ –≤–∞–ª–∏–¥–Ω–æ—Å—Ç
        if (u < 0 || u >= n || v < 0 || v >= n) {
            return false;
        }
        return adj[u][v] == 1;
    }
    // –í—Ä–µ–º–µ–≤–∞ —Å–ª–æ–∂–Ω–æ—Å—Ç: O(1)
};

// –ó–∞ —Å–ø–∏—Å—ä–∫ –Ω–∞ —Å—ä—Å–µ–¥—Å—Ç–≤–æ
class ListGraph {
    map<int, list<int>> adj;
public:
    void addEdge(int u, int v) {
        adj[u].push_back(v);
        adj[v].push_back(u); // –ó–∞ –Ω–µ–Ω–∞—Å–æ—á–µ–Ω –≥—Ä–∞—Ñ
    }

    bool hasEdge(int u, int v) {
        // –ü—Ä–æ–≤–µ—Ä—è–≤–∞–º–µ –¥–∞–ª–∏ u —Å—ä—â–µ—Å—Ç–≤—É–≤–∞ –≤ –≥—Ä–∞—Ñ–∞
        if (adj.find(u) == adj.end()) {
            return false;
        }

        // –¢—ä—Ä—Å–∏–º v –≤ —Å–ø–∏—Å—ä–∫–∞ –Ω–∞ —Å—ä—Å–µ–¥–∏ –Ω–∞ u
        return find(adj[u].begin(), adj[u].end(), v) != adj[u].end();
    }
    // –í—Ä–µ–º–µ–≤–∞ —Å–ª–æ–∂–Ω–æ—Å—Ç: O(degree(u)) ‚âà O(V) –≤ –Ω–∞–π-–ª–æ—à–∏—è —Å–ª—É—á–∞–π
};
```

**–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –Ω–∞ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏—Ç–µ:**

| –ü—Ä–µ–¥—Å—Ç–∞–≤—è–Ω–µ | hasEdge –°–ª–æ–∂–Ω–æ—Å—Ç | –û–±—è—Å–Ω–µ–Ω–∏–µ |
|-------------|------------------|-----------|
| –ú–∞—Ç—Ä–∏—Ü–∞ | O(1) | –î–∏—Ä–µ–∫—Ç–µ–Ω –¥–æ—Å—Ç—ä–ø –¥–æ –∫–ª–µ—Ç–∫–∞ |
| –°–ø–∏—Å—ä–∫ | O(degree) | –¢—Ä—è–±–≤–∞ –¥–∞ —Å–µ —Ç—ä—Ä—Å–∏ –≤ —Å–ø–∏—Å—ä–∫–∞ |

**–ó–∞–∫–ª—é—á–µ–Ω–∏–µ:** –ú–∞—Ç—Ä–∏—Ü–∞—Ç–∞ –Ω–∞ —Å—ä—Å–µ–¥—Å—Ç–≤–æ –µ –ø–æ-–±—ä—Ä–∑–∞ –∑–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Ä–µ–±—Ä–∞, –Ω–æ –∏–∑–ø–æ–ª–∑–≤–∞ –ø–æ–≤–µ—á–µ –ø–∞–º–µ—Ç.

</CollapsibleSection>

---

<ExerciseCard
  difficulty="medium"
  timeEstimate="30 min"
  tags={["dfs", "connected-components"]}
>

### –°–≤—ä—Ä–∑–∞–Ω–∏ –ö–æ–º–ø–æ–Ω–µ–Ω—Ç–∏

–ù–∞–ø–∏—à–µ—Ç–µ —Ñ—É–Ω–∫—Ü–∏—è, –∫–æ—è—Ç–æ –∏–∑–ø–æ–ª–∑–≤–∞ DFS –∑–∞ –±—Ä–æ–µ–Ω–µ –Ω–∞ —Å–≤—ä—Ä–∑–∞–Ω–∏—Ç–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∏ –≤ –Ω–µ–Ω–∞—Å–æ—á–µ–Ω –≥—Ä–∞—Ñ, –ø—Ä–µ–¥—Å—Ç–∞–≤–µ–Ω –∫–∞—Ç–æ —Å–ø–∏—Å—ä–∫ –Ω–∞ —Å—ä—Å–µ–¥—Å—Ç–≤–æ:

```cpp
int countComponents(const map<int, list<int>>& graph) {
    // YOUR CODE HERE
}
```

–¢–µ—Å—Ç–≤–∞–π—Ç–µ —Å —Ç–æ–∑–∏ –≥—Ä–∞—Ñ:
```
0: [1]
1: [0, 2]
2: [1]
3: [4]
4: [3]
5: []
```
–û—á–∞–∫–≤–∞–Ω –∏–∑—Ö–æ–¥: 3 –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞

</ExerciseCard>

<CollapsibleSection title="‚úÖ –†–µ—à–µ–Ω–∏–µ" icon="‚úÖ">

```cpp
#include <map>
#include <list>
#include <unordered_set>
using namespace std;

void DFS(const map<int, list<int>>& graph, int v, unordered_set<int>& visited) {
    visited.insert(v);

    // –ü—Ä–æ–≤–µ—Ä—è–≤–∞–º–µ –¥–∞–ª–∏ –≤—ä—Ä—Ö—ä—Ç –∏–º–∞ —Å—ä—Å–µ–¥–∏
    if (graph.find(v) != graph.end()) {
        for (int neighbor : graph.at(v)) {
            if (visited.find(neighbor) == visited.end()) {
                DFS(graph, neighbor, visited);
            }
        }
    }
}

int countComponents(const map<int, list<int>>& graph) {
    unordered_set<int> visited;
    int count = 0;

    // –û–±—Ö–æ–∂–¥–∞–º–µ –≤—Å–∏—á–∫–∏ –≤—ä—Ä—Ö–æ–≤–µ –≤ –≥—Ä–∞—Ñ–∞
    for (const auto& [vertex, neighbors] : graph) {
        if (visited.find(vertex) == visited.end()) {
            DFS(graph, vertex, visited);
            count++; // –ù–æ–≤ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç
        }
    }

    return count;
}

// –¢–µ—Å—Ç–≤–∞–Ω–µ
int main() {
    map<int, list<int>> graph;
    graph[0] = {1};
    graph[1] = {0, 2};
    graph[2] = {1};
    graph[3] = {4};
    graph[4] = {3};
    graph[5] = {};

    cout << "–ë—Ä–æ–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∏: " << countComponents(graph) << endl;
    // –ò–∑—Ö–æ–¥: –ë—Ä–æ–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∏: 3

    return 0;
}
```

**–û–±—è—Å–Ω–µ–Ω–∏–µ:**
- –ö–æ–º–ø–æ–Ω–µ–Ω—Ç 1: {0, 1, 2}
- –ö–æ–º–ø–æ–Ω–µ–Ω—Ç 2: {3, 4}
- –ö–æ–º–ø–æ–Ω–µ–Ω—Ç 3: {5}

**–í—Ä–µ–º–µ–≤–∞ —Å–ª–æ–∂–Ω–æ—Å—Ç:** O(V + E) - –≤—Å–µ–∫–∏ –≤—Ä—ä—Ö –∏ —Ä–µ–±—Ä–æ —Å–µ –ø–æ—Å–µ—â–∞–≤–∞ –≤–µ–¥–Ω—ä–∂

</CollapsibleSection>

---

## –ù–∞–ø—Ä–µ–¥–Ω–∞–ª–∏ –ü—Ä–∏–ª–æ–∂–µ–Ω–∏—è (HARD)

<ExerciseCard
  difficulty="hard"
  timeEstimate="40 min"
  tags={["bfs", "shortest-path", "path-reconstruction"]}
>

### –ù–∞–π-–∫—Ä–∞—Ç—ä–∫ –ü—ä—Ç —Å BFS

–ò–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞–π—Ç–µ —Ñ—É–Ω–∫—Ü–∏—è, –∫–æ—è—Ç–æ –Ω–∞–º–∏—Ä–∞ –Ω–∞–π-–∫—Ä–∞—Ç–∫–∏—è –ø—ä—Ç –º–µ–∂–¥—É –¥–≤–∞ –≤—ä—Ä—Ö–∞ –≤ –Ω–µ–ø—Ä–µ—Ç–µ–≥–ª–µ–Ω –≥—Ä–∞—Ñ, –∏–∑–ø–æ–ª–∑–≤–∞–π–∫–∏ BFS. –§—É–Ω–∫—Ü–∏—è—Ç–∞ —Ç—Ä—è–±–≤–∞ –¥–∞ –≤—ä—Ä–Ω–µ –∫–∞–∫—Ç–æ —Ä–∞–∑—Å—Ç–æ—è–Ω–∏–µ—Ç–æ, —Ç–∞–∫–∞ –∏ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–Ω–∏—è –ø—ä—Ç.

```cpp
pair<int, vector<int>> shortestPath(
    const map<int, list<int>>& graph,
    int start,
    int end
) {
    // Return {distance, path}
    // If no path exists, return {-1, {}}
    // YOUR CODE HERE
}
```

</ExerciseCard>

<CollapsibleSection title="‚úÖ –†–µ—à–µ–Ω–∏–µ" icon="‚úÖ">

```cpp
#include <map>
#include <list>
#include <vector>
#include <queue>
#include <unordered_map>
#include <algorithm>
using namespace std;

pair<int, vector<int>> shortestPath(
    const map<int, list<int>>& graph,
    int start,
    int end
) {
    // –ê–∫–æ –Ω–∞—á–∞–ª–Ω–∏—è—Ç –≤—Ä—ä—Ö –Ω–µ —Å—ä—â–µ—Å—Ç–≤—É–≤–∞ –≤ –≥—Ä–∞—Ñ–∞
    if (graph.find(start) == graph.end()) {
        return {-1, {}};
    }

    queue<int> q;
    unordered_map<int, int> parent; // –ó–∞ –≤—ä–∑—Å—Ç–∞–Ω–æ–≤—è–≤–∞–Ω–µ –Ω–∞ –ø—ä—Ç—è
    unordered_map<int, int> distance;

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
    q.push(start);
    distance[start] = 0;
    parent[start] = -1; // –ù–∞—á–∞–ª–Ω–∏—è—Ç –≤—Ä—ä—Ö –Ω—è–º–∞ parent

    // BFS
    while (!q.empty()) {
        int v = q.front();
        q.pop();

        // –ê–∫–æ —Å–º–µ —Å—Ç–∏–≥–Ω–∞–ª–∏ –¥–æ —Ü–µ–ª—Ç–∞
        if (v == end) {
            // –í—ä–∑—Å—Ç–∞–Ω–æ–≤—è–≤–∞–Ω–µ –Ω–∞ –ø—ä—Ç—è
            vector<int> path;
            int current = end;
            while (current != -1) {
                path.push_back(current);
                current = parent[current];
            }
            reverse(path.begin(), path.end());

            return {distance[end], path};
        }

        // –û–±—Ö–æ–∂–¥–∞–Ω–µ –Ω–∞ —Å—ä—Å–µ–¥–∏—Ç–µ
        if (graph.find(v) != graph.end()) {
            for (int neighbor : graph.at(v)) {
                if (distance.find(neighbor) == distance.end()) {
                    distance[neighbor] = distance[v] + 1;
                    parent[neighbor] = v;
                    q.push(neighbor);
                }
            }
        }
    }

    // –ù—è–º–∞ –ø—ä—Ç –¥–æ end
    return {-1, {}};
}

// –¢–µ—Å—Ç–≤–∞–Ω–µ
int main() {
    map<int, list<int>> graph;
    graph[0] = {1, 2};
    graph[1] = {0, 3, 4};
    graph[2] = {0, 4};
    graph[3] = {1};
    graph[4] = {1, 2};

    auto [dist, path] = shortestPath(graph, 0, 3);

    cout << "–†–∞–∑—Å—Ç–æ—è–Ω–∏–µ: " << dist << endl;
    cout << "–ü—ä—Ç: ";
    for (int v : path) {
        cout << v << " ";
    }
    cout << endl;

    // –ò–∑—Ö–æ–¥: –†–∞–∑—Å—Ç–æ—è–Ω–∏–µ: 2
    //        –ü—ä—Ç: 0 1 3

    return 0;
}
```

**–í—Ä–µ–º–µ–≤–∞ —Å–ª–æ–∂–Ω–æ—Å—Ç:** O(V + E)
**–ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–∞ —Å–ª–æ–∂–Ω–æ—Å—Ç:** O(V)

</CollapsibleSection>

---

<ExerciseCard
  difficulty="hard"
  timeEstimate="40 min"
  tags={["dfs", "cycle-detection"]}
>

### –û—Ç–∫—Ä–∏–≤–∞–Ω–µ –Ω–∞ –¶–∏–∫—ä–ª

–ò–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞–π—Ç–µ —Ñ—É–Ω–∫—Ü–∏—è, –∏–∑–ø–æ–ª–∑–≤–∞—â–∞ DFS, –∫–æ—è—Ç–æ –æ—Ç–∫—Ä–∏–≤–∞ –¥–∞–ª–∏ –Ω–µ–Ω–∞—Å–æ—á–µ–Ω –≥—Ä–∞—Ñ —Å—ä–¥—ä—Ä–∂–∞ —Ü–∏–∫—ä–ª. –û–±—è—Å–Ω–µ—Ç–µ –≤–∞—à–∏—è –ø–æ–¥—Ö–æ–¥ –∏ –∑–∞—â–æ DFS –µ –ø–æ–¥—Ö–æ–¥—è—â –∑–∞ —Ç–æ–∑–∏ –ø—Ä–æ–±–ª–µ–º.

```cpp
bool hasCycle(const map<int, list<int>>& graph) {
    // YOUR CODE HERE
}
```

</ExerciseCard>

<CollapsibleSection title="üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞" icon="üí°">

–ü—Ä–∏ –Ω–µ–Ω–∞—Å–æ—á–µ–Ω –≥—Ä–∞—Ñ, —Ü–∏–∫—ä–ª —Å—ä—â–µ—Å—Ç–≤—É–≤–∞, –∞–∫–æ –ø–æ –≤—Ä–µ–º–µ –Ω–∞ DFS —Å—Ä–µ—â–Ω–µ–º –≤—Ä—ä—Ö, –∫–æ–π—Ç–æ –≤–µ—á–µ –µ –ø–æ—Å–µ—Ç–µ–Ω –∏ –Ω–µ –µ —Ä–æ–¥–∏—Ç–µ–ª—è—Ç –Ω–∞ —Ç–µ–∫—É—â–∏—è –≤—Ä—ä—Ö.

</CollapsibleSection>

<CollapsibleSection title="‚úÖ –†–µ—à–µ–Ω–∏–µ" icon="‚úÖ">

```cpp
#include <map>
#include <list>
#include <unordered_set>
using namespace std;

bool hasCycleDFS(const map<int, list<int>>& graph,
                 int v,
                 int parent,
                 unordered_set<int>& visited) {
    visited.insert(v);

    // –ü—Ä–æ–≤–µ—Ä—è–≤–∞–º–µ –¥–∞–ª–∏ –≤—ä—Ä—Ö—ä—Ç –∏–º–∞ —Å—ä—Å–µ–¥–∏
    if (graph.find(v) != graph.end()) {
        for (int neighbor : graph.at(v)) {
            // –ê–∫–æ —Å—ä—Å–µ–¥—ä—Ç –Ω–µ –µ –ø–æ—Å–µ—Ç–µ–Ω, —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ –≥–æ –ø—Ä–æ–≤–µ—Ä—è–≤–∞–º–µ
            if (visited.find(neighbor) == visited.end()) {
                if (hasCycleDFS(graph, neighbor, v, visited)) {
                    return true;
                }
            }
            // –ê–∫–æ —Å—ä—Å–µ–¥—ä—Ç –µ –ø–æ—Å–µ—Ç–µ–Ω –∏ –ù–ï –µ —Ä–æ–¥–∏—Ç–µ–ª—è—Ç, –∏–º–∞ —Ü–∏–∫—ä–ª
            else if (neighbor != parent) {
                return true;
            }
        }
    }

    return false;
}

bool hasCycle(const map<int, list<int>>& graph) {
    unordered_set<int> visited;

    // –ü—Ä–æ–≤–µ—Ä—è–≤–∞–º–µ –≤—Å–µ–∫–∏ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç
    for (const auto& [vertex, neighbors] : graph) {
        if (visited.find(vertex) == visited.end()) {
            if (hasCycleDFS(graph, vertex, -1, visited)) {
                return true;
            }
        }
    }

    return false;
}

// –¢–µ—Å—Ç–≤–∞–Ω–µ
int main() {
    // –ì—Ä–∞—Ñ —Å —Ü–∏–∫—ä–ª: 0-1-2-0
    map<int, list<int>> graph1;
    graph1[0] = {1, 2};
    graph1[1] = {0, 2};
    graph1[2] = {0, 1};

    cout << "–ì—Ä–∞—Ñ 1 –∏–º–∞ —Ü–∏–∫—ä–ª: " << (hasCycle(graph1) ? "–î–∞" : "–ù–µ") << endl;
    // –ò–∑—Ö–æ–¥: –î–∞

    // –ì—Ä–∞—Ñ –±–µ–∑ —Ü–∏–∫—ä–ª (–¥—ä—Ä–≤–æ)
    map<int, list<int>> graph2;
    graph2[0] = {1, 2};
    graph2[1] = {0, 3};
    graph2[2] = {0};
    graph2[3] = {1};

    cout << "–ì—Ä–∞—Ñ 2 –∏–º–∞ —Ü–∏–∫—ä–ª: " << (hasCycle(graph2) ? "–î–∞" : "–ù–µ") << endl;
    // –ò–∑—Ö–æ–¥: –ù–µ

    return 0;
}
```

**–û–±—è—Å–Ω–µ–Ω–∏–µ:**
- –ò–∑–ø–æ–ª–∑–≤–∞–º–µ DFS –∏ –ø—Ä–æ—Å–ª–µ–¥—è–≤–∞–º–µ —Ä–æ–¥–∏—Ç–µ–ª—è –Ω–∞ –≤—Å–µ–∫–∏ –≤—Ä—ä—Ö
- –ê–∫–æ —Å—Ä–µ—â–Ω–µ–º –ø–æ—Å–µ—Ç–µ–Ω –≤—Ä—ä—Ö, –∫–æ–π—Ç–æ –Ω–µ –µ —Ä–æ–¥–∏—Ç–µ–ª—è—Ç, –∑–Ω–∞—á–∏ –∏–º–∞ —Ü–∏–∫—ä–ª
- DFS –µ –ø–æ–¥—Ö–æ–¥—è—â, –∑–∞—â–æ—Ç–æ –º–æ–∂–µ –¥–∞ –æ—Ç–∫—Ä–∏–µ back edges (—Ä–µ–±—Ä–∞ –∫—ä–º –≤–µ—á–µ –ø–æ—Å–µ—Ç–µ–Ω–∏ –≤—ä—Ä—Ö–æ–≤–µ)

**–í—Ä–µ–º–µ–≤–∞ —Å–ª–æ–∂–Ω–æ—Å—Ç:** O(V + E)

</CollapsibleSection>

---

<ExerciseCard
  difficulty="hard"
  timeEstimate="45 min"
  tags={["bfs", "graph-coloring", "bipartite"]}
>

### Bipartite Graph Check

–ù–∞–ø–∏—à–µ—Ç–µ —Ñ—É–Ω–∫—Ü–∏—è, –∫–æ—è—Ç–æ –æ–ø—Ä–µ–¥–µ–ª—è –¥–∞–ª–∏ –≥—Ä–∞—Ñ –µ bipartite (–º–æ–∂–µ –¥–∞ —Å–µ –æ—Ü–≤–µ—Ç–∏ —Å –¥–≤–∞ —Ü–≤—è—Ç–∞ —Ç–∞–∫–∞, —á–µ –Ω–∏–∫–æ–∏ —Å—ä—Å–µ–¥–Ω–∏ –≤—ä—Ä—Ö–æ–≤–µ –¥–∞ –Ω—è–º–∞—Ç —Å—ä—â–∏—è —Ü–≤—è—Ç). –ò–∑–ø–æ–ª–∑–≤–∞–π—Ç–µ BFS –∑–∞ –≤–∞—à–∞—Ç–∞ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏—è.

```cpp
bool isBipartite(const map<int, list<int>>& graph, int start) {
    // YOUR CODE HERE
}
```

</ExerciseCard>

<CollapsibleSection title="üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞" icon="üí°">

–û–ø–∏—Ç–∞–π—Ç–µ —Å–µ –¥–∞ –æ—Ü–≤–µ—Ç–∏—Ç–µ –≥—Ä–∞—Ñ–∞ —Å –¥–≤–∞ —Ü–≤—è—Ç–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä 0 –∏ 1), –∏–∑–ø–æ–ª–∑–≤–∞–π–∫–∏ BFS. –ê–∫–æ —Å—Ä–µ—â–Ω–µ—Ç–µ —Å—ä—Å–µ–¥–Ω–∏ –≤—ä—Ä—Ö–æ–≤–µ —Å—ä—Å —Å—ä—â–∏—è —Ü–≤—è—Ç, –≥—Ä–∞—Ñ—ä—Ç –Ω–µ –µ bipartite.

</CollapsibleSection>

<CollapsibleSection title="‚úÖ –†–µ—à–µ–Ω–∏–µ" icon="‚úÖ">

```cpp
#include <map>
#include <list>
#include <queue>
#include <unordered_map>
using namespace std;

bool isBipartite(const map<int, list<int>>& graph) {
    unordered_map<int, int> color; // -1: –Ω–µ–æ—Ü–≤–µ—Ç–µ–Ω, 0: —Ü–≤—è—Ç 0, 1: —Ü–≤—è—Ç 1

    // –ü—Ä–æ–≤–µ—Ä—è–≤–∞–º–µ –≤—Å–∏—á–∫–∏ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∏
    for (const auto& [vertex, neighbors] : graph) {
        if (color.find(vertex) == color.end()) {
            // BFS –∑–∞ —Ç–µ–∫—É—â–∏—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç
            queue<int> q;
            q.push(vertex);
            color[vertex] = 0; // –ó–∞–ø–æ—á–≤–∞–º–µ —Å —Ü–≤—è—Ç 0

            while (!q.empty()) {
                int v = q.front();
                q.pop();

                // –ü—Ä–æ–≤–µ—Ä—è–≤–∞–º–µ —Å—ä—Å–µ–¥–∏—Ç–µ
                if (graph.find(v) != graph.end()) {
                    for (int neighbor : graph.at(v)) {
                        if (color.find(neighbor) == color.end()) {
                            // –û—Ü–≤–µ—Ç—è–≤–∞–º–µ —Å—ä—Å–µ–¥–∞ —Å –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–µ–Ω —Ü–≤—è—Ç
                            color[neighbor] = 1 - color[v];
                            q.push(neighbor);
                        }
                        else if (color[neighbor] == color[v]) {
                            // –°—ä—Å–µ–¥–Ω–∏ –≤—ä—Ä—Ö–æ–≤–µ —Å—ä—Å —Å—ä—â–∏—è —Ü–≤—è—Ç - –Ω–µ –µ bipartite
                            return false;
                        }
                    }
                }
            }
        }
    }

    return true;
}

// –¢–µ—Å—Ç–≤–∞–Ω–µ
int main() {
    // Bipartite –≥—Ä–∞—Ñ (–∫–≤–∞–¥—Ä–∞—Ç)
    map<int, list<int>> graph1;
    graph1[0] = {1, 3};
    graph1[1] = {0, 2};
    graph1[2] = {1, 3};
    graph1[3] = {0, 2};

    cout << "–ì—Ä–∞—Ñ 1 –µ bipartite: " << (isBipartite(graph1) ? "–î–∞" : "–ù–µ") << endl;
    // –ò–∑—Ö–æ–¥: –î–∞

    // –ù–µ –µ bipartite (—Ç—Ä–∏—ä–≥—ä–ª–Ω–∏–∫)
    map<int, list<int>> graph2;
    graph2[0] = {1, 2};
    graph2[1] = {0, 2};
    graph2[2] = {0, 1};

    cout << "–ì—Ä–∞—Ñ 2 –µ bipartite: " << (isBipartite(graph2) ? "–î–∞" : "–ù–µ") << endl;
    // –ò–∑—Ö–æ–¥: –ù–µ

    return 0;
}
```

**–û–±—è—Å–Ω–µ–Ω–∏–µ:**
- Bipartite –≥—Ä–∞—Ñ –º–æ–∂–µ –¥–∞ —Å–µ —Ä–∞–∑–¥–µ–ª–∏ –Ω–∞ –¥–≤–µ –º–Ω–æ–∂–µ—Å—Ç–≤–∞, –∫—ä–¥–µ—Ç–æ –≤—Å–∏—á–∫–∏ —Ä–µ–±—Ä–∞ —Å–≤—ä—Ä–∑–≤–∞—Ç –≤—ä—Ä—Ö–æ–≤–µ –æ—Ç —Ä–∞–∑–ª–∏—á–Ω–∏—Ç–µ –º–Ω–æ–∂–µ—Å—Ç–≤–∞
- –ò–∑–ø–æ–ª–∑–≤–∞–º–µ BFS –∏ —Å–µ –æ–ø–∏—Ç–≤–∞–º–µ –¥–∞ –æ—Ü–≤–µ—Ç–∏–º –≥—Ä–∞—Ñ–∞ —Å –¥–≤–∞ —Ü–≤—è—Ç–∞
- –ê–∫–æ –¥–≤–∞ —Å—ä—Å–µ–¥–Ω–∏ –≤—ä—Ä—Ö–∞ –∏–º–∞—Ç —Å—ä—â–∏—è —Ü–≤—è—Ç, –≥—Ä–∞—Ñ—ä—Ç –Ω–µ –µ bipartite

**–í—Ä–µ–º–µ–≤–∞ —Å–ª–æ–∂–Ω–æ—Å—Ç:** O(V + E)

</CollapsibleSection>

---

<ExerciseCard
  difficulty="hard"
  timeEstimate="35 min"
  tags={["graph-representation", "conversion"]}
>

### –ö–æ–Ω–≤–µ—Ä—Å–∏—è –º–µ–∂–¥—É –ü—Ä–µ–¥—Å—Ç–∞–≤—è–Ω–∏—è

–ò–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞–π—Ç–µ –¥–≤–µ —Ñ—É–Ω–∫—Ü–∏–∏ –∑–∞ –∫–æ–Ω–≤–µ—Ä—Å–∏—è:

```cpp
// –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–∞–Ω–µ –Ω–∞ –º–∞—Ç—Ä–∏—Ü–∞ –Ω–∞ —Å—ä—Å–µ–¥—Å—Ç–≤–æ –≤ —Å–ø–∏—Å—ä–∫ –Ω–∞ —Å—ä—Å–µ–¥—Å—Ç–≤–æ
map<int, list<int>> matrixToList(const vector<vector<int>>& matrix) {
    // YOUR CODE HERE
}

// –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–∞–Ω–µ –Ω–∞ —Å–ø–∏—Å—ä–∫ –Ω–∞ —Å—ä—Å–µ–¥—Å—Ç–≤–æ –≤ –º–∞—Ç—Ä–∏—Ü–∞ –Ω–∞ —Å—ä—Å–µ–¥—Å—Ç–≤–æ
vector<vector<int>> listToMatrix(const map<int, list<int>>& adjList, int n) {
    // YOUR CODE HERE
}
```

</ExerciseCard>

<CollapsibleSection title="‚úÖ –†–µ—à–µ–Ω–∏–µ" icon="‚úÖ">

```cpp
#include <vector>
#include <map>
#include <list>
using namespace std;

// –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–∞–Ω–µ –Ω–∞ –º–∞—Ç—Ä–∏—Ü–∞ –Ω–∞ —Å—ä—Å–µ–¥—Å—Ç–≤–æ –≤ —Å–ø–∏—Å—ä–∫ –Ω–∞ —Å—ä—Å–µ–¥—Å—Ç–≤–æ
map<int, list<int>> matrixToList(const vector<vector<int>>& matrix) {
    map<int, list<int>> adjList;
    int n = matrix.size();

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (matrix[i][j] != 0) {
                adjList[i].push_back(j);
            }
        }
    }

    return adjList;
}

// –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–∞–Ω–µ –Ω–∞ —Å–ø–∏—Å—ä–∫ –Ω–∞ —Å—ä—Å–µ–¥—Å—Ç–≤–æ –≤ –º–∞—Ç—Ä–∏—Ü–∞ –Ω–∞ —Å—ä—Å–µ–¥—Å—Ç–≤–æ
vector<vector<int>> listToMatrix(const map<int, list<int>>& adjList, int n) {
    vector<vector<int>> matrix(n, vector<int>(n, 0));

    for (const auto& [vertex, neighbors] : adjList) {
        for (int neighbor : neighbors) {
            matrix[vertex][neighbor] = 1;
        }
    }

    return matrix;
}

// –ü–æ–º–æ—â–Ω–∏ —Ñ—É–Ω–∫—Ü–∏–∏ –∑–∞ —Ç–µ—Å—Ç–≤–∞–Ω–µ
void printMatrix(const vector<vector<int>>& matrix) {
    for (const auto& row : matrix) {
        for (int val : row) {
            cout << val << " ";
        }
        cout << endl;
    }
}

void printList(const map<int, list<int>>& adjList) {
    for (const auto& [vertex, neighbors] : adjList) {
        cout << vertex << ": ";
        for (int neighbor : neighbors) {
            cout << neighbor << " ";
        }
        cout << endl;
    }
}

int main() {
    // –¢–µ—Å—Ç: –º–∞—Ç—Ä–∏—Ü–∞ -> —Å–ø–∏—Å—ä–∫ -> –º–∞—Ç—Ä–∏—Ü–∞
    vector<vector<int>> originalMatrix = {
        {0, 1, 1, 0},
        {1, 0, 0, 1},
        {1, 0, 0, 1},
        {0, 1, 1, 0}
    };

    cout << "–û—Ä–∏–≥–∏–Ω–∞–ª–Ω–∞ –º–∞—Ç—Ä–∏—Ü–∞:" << endl;
    printMatrix(originalMatrix);

    auto adjList = matrixToList(originalMatrix);
    cout << "\n–°–ø–∏—Å—ä–∫ –Ω–∞ —Å—ä—Å–µ–¥—Å—Ç–≤–æ:" << endl;
    printList(adjList);

    auto newMatrix = listToMatrix(adjList, 4);
    cout << "\n–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–∞–Ω–∞ –æ–±—Ä–∞—Ç–Ω–æ –º–∞—Ç—Ä–∏—Ü–∞:" << endl;
    printMatrix(newMatrix);

    return 0;
}
```

**–í—Ä–µ–º–µ–≤–∞ —Å–ª–æ–∂–Ω–æ—Å—Ç:**
- `matrixToList`: O(V¬≤) - —Ç—Ä—è–±–≤–∞ –¥–∞ –ø—Ä–æ–≤–µ—Ä–∏–º –≤—Å–∏—á–∫–∏ –∫–ª–µ—Ç–∫–∏
- `listToMatrix`: O(V + E) - –æ–±—Ö–æ–∂–¥–∞–º–µ –≤—Å–∏—á–∫–∏ —Ä–µ–±—Ä–∞

</CollapsibleSection>

---

<ExerciseCard
  difficulty="hard"
  timeEstimate="45 min"
  tags={["bfs", "graph-diameter", "shortest-path"]}
>

### –î–∏–∞–º–µ—Ç—ä—Ä –Ω–∞ –ì—Ä–∞—Ñ

–î–∏–∞–º–µ—Ç—ä—Ä—ä—Ç –Ω–∞ –≥—Ä–∞—Ñ –µ –Ω–∞–π-–¥—ä–ª–≥–∏—è—Ç –Ω–∞–π-–∫—Ä–∞—Ç—ä–∫ –ø—ä—Ç –º–µ–∂–¥—É –≤—Å–µ–∫–∏ –¥–≤–∞ –≤—ä—Ä—Ö–∞. –ò–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞–π—Ç–µ —Ñ—É–Ω–∫—Ü–∏—è –∑–∞ –∏–∑—á–∏—Å–ª—è–≤–∞–Ω–µ –Ω–∞ –¥–∏–∞–º–µ—Ç—ä—Ä–∞ –Ω–∞ —Å–≤—ä—Ä–∑–∞–Ω, –Ω–µ–Ω–∞—Å–æ—á–µ–Ω –≥—Ä–∞—Ñ.

```cpp
int graphDiameter(const map<int, list<int>>& graph) {
    // Hint: Run BFS from each vertex
    // YOUR CODE HERE
}
```

</ExerciseCard>

<CollapsibleSection title="üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞" icon="üí°">

–°—Ç–∞—Ä—Ç–∏—Ä–∞–π—Ç–µ BFS –æ—Ç –≤—Å–µ–∫–∏ –≤—Ä—ä—Ö –∏ –Ω–∞–º–µ—Ä–µ—Ç–µ –º–∞–∫—Å–∏–º–∞–ª–Ω–æ—Ç–æ —Ä–∞–∑—Å—Ç–æ—è–Ω–∏–µ. –î–∏–∞–º–µ—Ç—ä—Ä—ä—Ç –µ –º–∞–∫—Å–∏–º—É–º—ä—Ç –æ—Ç –≤—Å–∏—á–∫–∏ —Ç–µ–∑–∏ —Ä–∞–∑—Å—Ç–æ—è–Ω–∏—è.

</CollapsibleSection>

<CollapsibleSection title="‚úÖ –†–µ—à–µ–Ω–∏–µ" icon="‚úÖ">

```cpp
#include <map>
#include <list>
#include <queue>
#include <unordered_map>
#include <algorithm>
using namespace std;

// BFS, –∫–æ—è—Ç–æ –≤—Ä—ä—â–∞ –º–∞–∫—Å–∏–º–∞–ª–Ω–æ—Ç–æ —Ä–∞–∑—Å—Ç–æ—è–Ω–∏–µ –æ—Ç start
int bfsMaxDistance(const map<int, list<int>>& graph, int start) {
    queue<int> q;
    unordered_map<int, int> distance;

    q.push(start);
    distance[start] = 0;
    int maxDist = 0;

    while (!q.empty()) {
        int v = q.front();
        q.pop();

        if (graph.find(v) != graph.end()) {
            for (int neighbor : graph.at(v)) {
                if (distance.find(neighbor) == distance.end()) {
                    distance[neighbor] = distance[v] + 1;
                    maxDist = max(maxDist, distance[neighbor]);
                    q.push(neighbor);
                }
            }
        }
    }

    return maxDist;
}

int graphDiameter(const map<int, list<int>>& graph) {
    int diameter = 0;

    // –°—Ç–∞—Ä—Ç–∏—Ä–∞–º–µ BFS –æ—Ç –≤—Å–µ–∫–∏ –≤—Ä—ä—Ö
    for (const auto& [vertex, neighbors] : graph) {
        int maxDist = bfsMaxDistance(graph, vertex);
        diameter = max(diameter, maxDist);
    }

    return diameter;
}

// –¢–µ—Å—Ç–≤–∞–Ω–µ
int main() {
    // –õ–∏–Ω–µ–µ–Ω –≥—Ä–∞—Ñ: 0-1-2-3-4
    map<int, list<int>> graph;
    graph[0] = {1};
    graph[1] = {0, 2};
    graph[2] = {1, 3};
    graph[3] = {2, 4};
    graph[4] = {3};

    cout << "–î–∏–∞–º–µ—Ç—ä—Ä –Ω–∞ –≥—Ä–∞—Ñ–∞: " << graphDiameter(graph) << endl;
    // –ò–∑—Ö–æ–¥: 4 (–æ—Ç 0 –¥–æ 4)

    return 0;
}
```

**–í—Ä–µ–º–µ–≤–∞ —Å–ª–æ–∂–Ω–æ—Å—Ç:** O(V √ó (V + E)) - BFS –∑–∞ –≤—Å–µ–∫–∏ –≤—Ä—ä—Ö
**–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è:** –ó–∞ –¥—ä—Ä–≤–µ—Ç–∞ –º–æ–∂–µ –¥–∞ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ –¥–≤–∞ BFS (–ø—ä—Ä–≤–æ –æ—Ç –ø—Ä–æ–∏–∑–≤–æ–ª–µ–Ω –≤—Ä—ä—Ö, –ø–æ—Å–ª–µ –æ—Ç –Ω–∞–π-–æ—Ç–¥–∞–ª–µ—á–µ–Ω–∏—è)

</CollapsibleSection>

---

<ExerciseCard
  difficulty="hard"
  timeEstimate="60 min"
  tags={["design", "optimization", "graph-representation"]}
>

### Adaptive Graph Implementation

–ü—Ä–æ–µ–∫—Ç–∏—Ä–∞–π—Ç–µ –∏ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞–π—Ç–µ –∫–ª–∞—Å –∑–∞ –≥—Ä–∞—Ñ, –∫–æ–π—Ç–æ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –ø—Ä–µ–≤–∫–ª—é—á–≤–∞ –º–µ–∂–¥—É –º–∞—Ç—Ä–∏—Ü–∞ –∏ —Å–ø–∏—Å—ä–∫ –Ω–∞ —Å—ä—Å–µ–¥—Å—Ç–≤–æ –≤—ä–∑ –æ—Å–Ω–æ–≤–∞ –Ω–∞ –ø–ª—ä—Ç–Ω–æ—Å—Ç—Ç–∞ –Ω–∞ –≥—Ä–∞—Ñ–∞. –í–∫–ª—é—á–µ—Ç–µ:
- –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä, –∫–æ–π—Ç–æ –ø—Ä–∏–µ–º–∞ —Å–ø–∏—Å—ä–∫ —Å —Ä–µ–±—Ä–∞
- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ–Ω –∏–∑–±–æ—Ä –Ω–∞ –ø—Ä–µ–¥—Å—Ç–∞–≤—è–Ω–µ –≤—ä–∑ –æ—Å–Ω–æ–≤–∞ –Ω–∞ –±—Ä–æ—è —Ä–µ–±—Ä–∞
- –ú–µ—Ç–æ–¥–∏: `addEdge()`, `removeEdge()`, `hasEdge()`, `getNeighbors()`
- –û–±—è—Å–Ω–µ–Ω–∏–µ –Ω–∞ –≤–∞—à–µ—Ç–æ —Ä–µ—à–µ–Ω–∏–µ –∑–∞ –ø—Ä–∞–≥ –Ω–∞ –ø–ª—ä—Ç–Ω–æ—Å—Ç

```cpp
class AdaptiveGraph {
    // YOUR DESIGN HERE
public:
    AdaptiveGraph(vector<pair<int,int>> edges, int numVertices);
    void addEdge(int u, int v);
    void removeEdge(int u, int v);
    bool hasEdge(int u, int v);
    vector<int> getNeighbors(int v);
};
```

</ExerciseCard>

<CollapsibleSection title="üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞" icon="üí°">

–ò–∑–±–µ—Ä–µ—Ç–µ –ø—Ä–∞–≥ –∑–∞ –ø–ª—ä—Ç–Ω–æ—Å—Ç (–Ω–∞–ø—Ä–∏–º–µ—Ä 30-50% –æ—Ç V¬≤). –ê–∫–æ E > threshold, –∏–∑–ø–æ–ª–∑–≤–∞–π—Ç–µ –º–∞—Ç—Ä–∏—Ü–∞, –∏–Ω–∞—á–µ —Å–ø–∏—Å—ä–∫.

</CollapsibleSection>

<CollapsibleSection title="‚úÖ –†–µ—à–µ–Ω–∏–µ" icon="‚úÖ">

```cpp
#include <vector>
#include <map>
#include <list>
#include <algorithm>
using namespace std;

class AdaptiveGraph {
private:
    int n; // –ë—Ä–æ–π –≤—ä—Ä—Ö–æ–≤–µ
    int edgeCount;
    bool useMatrix; // true = matrix, false = list

    // –î–≤–µ—Ç–µ –ø—Ä–µ–¥—Å—Ç–∞–≤—è–Ω–∏—è
    vector<vector<int>> adjMatrix;
    map<int, list<int>> adjList;

    // –ü—Ä–∞–≥ –∑–∞ –ø–ª—ä—Ç–Ω–æ—Å—Ç (40% –æ—Ç –≤—ä–∑–º–æ–∂–Ω–∏—Ç–µ —Ä–µ–±—Ä–∞)
    const double DENSITY_THRESHOLD = 0.4;

    void decideRepresentation() {
        int maxEdges = n * (n - 1) / 2;
        double density = (double)edgeCount / maxEdges;
        useMatrix = (density > DENSITY_THRESHOLD);
    }

    void convertToMatrix() {
        adjMatrix.assign(n, vector<int>(n, 0));
        for (const auto& [vertex, neighbors] : adjList) {
            for (int neighbor : neighbors) {
                adjMatrix[vertex][neighbor] = 1;
            }
        }
        adjList.clear();
    }

    void convertToList() {
        adjList.clear();
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (adjMatrix[i][j] == 1) {
                    adjList[i].push_back(j);
                }
            }
        }
        adjMatrix.clear();
    }

public:
    AdaptiveGraph(vector<pair<int,int>> edges, int numVertices)
        : n(numVertices), edgeCount(edges.size()) {

        decideRepresentation();

        if (useMatrix) {
            adjMatrix.assign(n, vector<int>(n, 0));
            for (auto [u, v] : edges) {
                adjMatrix[u][v] = 1;
                adjMatrix[v][u] = 1; // –ù–µ–Ω–∞—Å–æ—á–µ–Ω –≥—Ä–∞—Ñ
            }
        } else {
            for (auto [u, v] : edges) {
                adjList[u].push_back(v);
                adjList[v].push_back(u); // –ù–µ–Ω–∞—Å–æ—á–µ–Ω –≥—Ä–∞—Ñ
            }
        }
    }

    void addEdge(int u, int v) {
        if (useMatrix) {
            if (adjMatrix[u][v] == 0) {
                adjMatrix[u][v] = 1;
                adjMatrix[v][u] = 1;
                edgeCount++;
            }
        } else {
            // –ü—Ä–æ–≤–µ—Ä—è–≤–∞–º–µ –¥–∞–ª–∏ —Ä–µ–±—Ä–æ—Ç–æ –≤–µ—á–µ —Å—ä—â–µ—Å—Ç–≤—É–≤–∞
            auto it = find(adjList[u].begin(), adjList[u].end(), v);
            if (it == adjList[u].end()) {
                adjList[u].push_back(v);
                adjList[v].push_back(u);
                edgeCount++;
            }
        }

        // –ü—Ä–æ–≤–µ—Ä—è–≤–∞–º–µ –¥–∞–ª–∏ —Ç—Ä—è–±–≤–∞ –¥–∞ –ø—Ä–µ–≤–∫–ª—é—á–∏–º –ø—Ä–µ–¥—Å—Ç–∞–≤—è–Ω–µ
        decideRepresentation();
        bool shouldUseMatrix = (double)edgeCount / (n * (n - 1) / 2) > DENSITY_THRESHOLD;
        if (shouldUseMatrix && !useMatrix) {
            convertToMatrix();
            useMatrix = true;
        }
    }

    void removeEdge(int u, int v) {
        if (useMatrix) {
            if (adjMatrix[u][v] == 1) {
                adjMatrix[u][v] = 0;
                adjMatrix[v][u] = 0;
                edgeCount--;
            }
        } else {
            adjList[u].remove(v);
            adjList[v].remove(u);
            edgeCount--;
        }

        // –ü—Ä–æ–≤–µ—Ä—è–≤–∞–º–µ –¥–∞–ª–∏ —Ç—Ä—è–±–≤–∞ –¥–∞ –ø—Ä–µ–≤–∫–ª—é—á–∏–º –∫—ä–º —Å–ø–∏—Å—ä–∫
        bool shouldUseList = (double)edgeCount / (n * (n - 1) / 2) <= DENSITY_THRESHOLD;
        if (shouldUseList && useMatrix) {
            convertToList();
            useMatrix = false;
        }
    }

    bool hasEdge(int u, int v) {
        if (useMatrix) {
            return adjMatrix[u][v] == 1;
        } else {
            return find(adjList[u].begin(), adjList[u].end(), v) != adjList[u].end();
        }
    }

    vector<int> getNeighbors(int v) {
        vector<int> neighbors;
        if (useMatrix) {
            for (int i = 0; i < n; i++) {
                if (adjMatrix[v][i] == 1) {
                    neighbors.push_back(i);
                }
            }
        } else {
            for (int neighbor : adjList[v]) {
                neighbors.push_back(neighbor);
            }
        }
        return neighbors;
    }

    string getCurrentRepresentation() const {
        return useMatrix ? "Matrix" : "List";
    }
};

// –¢–µ—Å—Ç–≤–∞–Ω–µ
int main() {
    vector<pair<int,int>> edges = {{0,1}, {1,2}, {2,3}};
    AdaptiveGraph g(edges, 4);

    cout << "–ù–∞—á–∞–ª–Ω–æ –ø—Ä–µ–¥—Å—Ç–∞–≤—è–Ω–µ: " << g.getCurrentRepresentation() << endl;

    // –î–æ–±–∞–≤—è–º–µ –º–Ω–æ–≥–æ —Ä–µ–±—Ä–∞
    g.addEdge(0, 2);
    g.addEdge(0, 3);
    g.addEdge(1, 3);

    cout << "–°–ª–µ–¥ –¥–æ–±–∞–≤—è–Ω–µ –Ω–∞ —Ä–µ–±—Ä–∞: " << g.getCurrentRepresentation() << endl;

    return 0;
}
```

**–û–±—è—Å–Ω–µ–Ω–∏–µ –Ω–∞ –¥–∏–∑–∞–π–Ω–∞:**
- **–ü—Ä–∞–≥ 40%:** –ü—Ä–∏ –ø–ª—ä—Ç–Ω–æ—Å—Ç –ø–æ–¥ 40% —Å–ø–∏—Å—ä–∫—ä—Ç –µ –ø–æ-–µ—Ñ–µ–∫—Ç–∏–≤–µ–Ω
- **–î–∏–Ω–∞–º–∏—á–Ω–æ –ø—Ä–µ–≤–∫–ª—é—á–≤–∞–Ω–µ:** –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ —Å–µ –∞–¥–∞–ø—Ç–∏—Ä–∞ –ø—Ä–∏ –¥–æ–±–∞–≤—è–Ω–µ/–ø—Ä–µ–º–∞—Ö–≤–∞–Ω–µ –Ω–∞ —Ä–µ–±—Ä–∞
- **Trade-offs:** –ö–æ–Ω–≤–µ—Ä—Å–∏—è—Ç–∞ –æ—Ç–Ω–µ–º–∞ –≤—Ä–µ–º–µ, –Ω–æ –¥—ä–ª–≥–æ—Å—Ä–æ—á–Ω–∏—Ç–µ –ø–æ–ª–∑–∏ —Å–∞ –ø–æ-–≥–æ–ª–µ–º–∏

</CollapsibleSection>

---

## –ë–æ–Ω—É—Å –ü—Ä–µ–¥–∏–∑–≤–∏–∫–∞—Ç–µ–ª—Å—Ç–≤–æ (HARD)

<ExerciseCard
  difficulty="hard"
  timeEstimate="45 min"
  tags={["bfs", "multi-source", "advanced"]}
>

### Multi-Source BFS

–ò–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞–π—Ç–µ –º–æ–¥–∏—Ñ–∏—Ü–∏—Ä–∞–Ω BFS, –∫–æ–π—Ç–æ —Å—Ç–∞—Ä—Ç–∏—Ä–∞ –æ—Ç –º–Ω–æ–∂–µ—Å—Ç–≤–æ –∏–∑—Ç–æ—á–Ω–∏—Ü–∏ –µ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ. –¢–æ–≤–∞ –µ –ø–æ–ª–µ–∑–Ω–æ –≤ —Å—Ü–µ–Ω–∞—Ä–∏–∏ –∫–∞—Ç–æ –Ω–∞–º–∏—Ä–∞–Ω–µ –Ω–∞ –Ω–∞–π-–±–ª–∏–∑–∫–∞—Ç–∞ –±–æ–ª–Ω–∏—Ü–∞ –æ—Ç –≤—Å—è–∫–∞ —Ç–æ—á–∫–∞ –≤ –≥—Ä–∞–¥–∞.

```cpp
map<int, int> multiSourceBFS(
    const map<int, list<int>>& graph,
    const vector<int>& sources
) {
    // Return map: vertex -> distance to nearest source
    // YOUR CODE HERE
}
```

</ExerciseCard>

<CollapsibleSection title="üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞" icon="üí°">

–î–æ–±–∞–≤–µ—Ç–µ –≤—Å–∏—á–∫–∏ –∏–∑—Ç–æ—á–Ω–∏—Ü–∏ –≤ –æ–ø–∞—à–∫–∞—Ç–∞ –µ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ –≤ –Ω–∞—á–∞–ª–æ—Ç–æ. –°–ª–µ–¥ —Ç–æ–≤–∞ BFS –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ —â–µ –Ω–∞–º–µ—Ä–∏ –Ω–∞–π-–∫—Ä–∞—Ç–∫–æ—Ç–æ —Ä–∞–∑—Å—Ç–æ—è–Ω–∏–µ –æ—Ç –≤—Å–µ–∫–∏ –≤—Ä—ä—Ö –¥–æ –Ω–∞–π-–±–ª–∏–∑–∫–∏—è –∏–∑—Ç–æ—á–Ω–∏–∫.

</CollapsibleSection>

<CollapsibleSection title="‚úÖ –†–µ—à–µ–Ω–∏–µ" icon="‚úÖ">

```cpp
#include <map>
#include <list>
#include <vector>
#include <queue>
#include <unordered_map>
using namespace std;

map<int, int> multiSourceBFS(
    const map<int, list<int>>& graph,
    const vector<int>& sources
) {
    queue<int> q;
    unordered_map<int, int> distance;

    // –î–æ–±–∞–≤—è–º–µ –≤—Å–∏—á–∫–∏ –∏–∑—Ç–æ—á–Ω–∏—Ü–∏ –≤ –æ–ø–∞—à–∫–∞—Ç–∞
    for (int source : sources) {
        q.push(source);
        distance[source] = 0;
    }

    // –°—Ç–∞–Ω–¥–∞—Ä—Ç–µ–Ω BFS
    while (!q.empty()) {
        int v = q.front();
        q.pop();

        if (graph.find(v) != graph.end()) {
            for (int neighbor : graph.at(v)) {
                if (distance.find(neighbor) == distance.end()) {
                    distance[neighbor] = distance[v] + 1;
                    q.push(neighbor);
                }
            }
        }
    }

    // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–∞–º–µ –≤ map –∑–∞ –≤—Ä—ä—â–∞–Ω–µ
    map<int, int> result(distance.begin(), distance.end());
    return result;
}

// –¢–µ—Å—Ç–≤–∞–Ω–µ
int main() {
    // –ì—Ä–∞—Ñ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–≤–∞—â –≥—Ä–∞–¥—Å–∫–∞ –º—Ä–µ–∂–∞
    map<int, list<int>> cityGraph;
    cityGraph[0] = {1, 2};
    cityGraph[1] = {0, 3};
    cityGraph[2] = {0, 4};
    cityGraph[3] = {1, 5};
    cityGraph[4] = {2, 5};
    cityGraph[5] = {3, 4};

    // –ë–æ–ª–Ω–∏—Ü–∏ –Ω–∞ –ø–æ–∑–∏—Ü–∏–∏ 0 –∏ 5
    vector<int> hospitals = {0, 5};

    auto distances = multiSourceBFS(cityGraph, hospitals);

    cout << "–†–∞–∑—Å—Ç–æ—è–Ω–∏—è –¥–æ –Ω–∞–π-–±–ª–∏–∑–∫–∞ –±–æ–ª–Ω–∏—Ü–∞:" << endl;
    for (const auto& [vertex, dist] : distances) {
        cout << "–í—Ä—ä—Ö " << vertex << ": " << dist << " —Å—Ç—ä–ø–∫–∏" << endl;
    }

    // –ò–∑—Ö–æ–¥ –ø–æ–∫–∞–∑–≤–∞ —Ä–∞–∑—Å—Ç–æ—è–Ω–∏–µ—Ç–æ –æ—Ç –≤—Å–µ–∫–∏ –≤—Ä—ä—Ö –¥–æ –Ω–∞–π-–±–ª–∏–∑–∫–∞—Ç–∞ –±–æ–ª–Ω–∏—Ü–∞

    return 0;
}
```

**–ü—Ä–∏–ª–æ–∂–µ–Ω–∏—è:**
- –ù–∞–º–∏—Ä–∞–Ω–µ –Ω–∞ –Ω–∞–π-–±–ª–∏–∑–∫–∞ –±–æ–ª–Ω–∏—Ü–∞, –ø–æ–∂–∞—Ä–Ω–∞, –ø–æ–ª–∏—Ü–∏—è
- Routing –≤ –º—Ä–µ–∂–∏ —Å –º–Ω–æ–∂–µ—Å—Ç–≤–æ –∏–∑–ª–∞–∑–Ω–∏ —Ç–æ—á–∫–∏
- Game AI (pathfinding —Å –º–Ω–æ–∂–µ—Å—Ç–≤–æ —Ü–µ–ª–∏)

**–í—Ä–µ–º–µ–≤–∞ —Å–ª–æ–∂–Ω–æ—Å—Ç:** O(V + E) - —Å—ä—â–∞—Ç–∞ –∫–∞—Ç–æ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–µ–Ω BFS

</CollapsibleSection>

---

## –î–æ–ø—ä–ª–Ω–∏—Ç–µ–ª–Ω–∏ –†–µ—Å—É—Ä—Å–∏ –∑–∞ –ü—Ä–∞–∫—Ç–∏–∫–∞

### –û–Ω–ª–∞–π–Ω –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏ –ü–ª–∞—Ç—Ñ–æ—Ä–º–∏

- [LeetCode - Graph Problems](https://leetcode.com/tag/graph/) - –ì–æ–ª—è–º–∞ –∫–æ–ª–µ–∫—Ü–∏—è –æ—Ç –∑–∞–¥–∞—á–∏ –∑–∞ –≥—Ä–∞—Ñ–∏
- [HackerRank - Graph Theory](https://www.hackerrank.com/domains/algorithms?filters%5Bsubdomains%5D%5B%5D=graph-theory) - –ó–∞–¥–∞—á–∏ –æ—Ç –Ω–∞—á–∞–ª–Ω–æ –¥–æ –Ω–∞–ø—Ä–µ–¥–Ω–∞–ª–æ –Ω–∏–≤–æ
- [CodeForces - Graphs](https://codeforces.com/problemset?tags=graphs) - –°—ä—Å—Ç–µ–∑–∞—Ç–µ–ª–Ω–∏ –∑–∞–¥–∞—á–∏

### –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –Ω–∞ –ê–ª–≥–æ—Ä–∏—Ç–º–∏

- [VisuAlgo - Graph Traversal](https://visualgo.net/en/dfsbfs) - –ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–∞ –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è
- [Graph Online](https://graphonline.ru/en/) - –°—ä–∑–¥–∞–≤–∞–Ω–µ –∏ —Ç–µ—Å—Ç–≤–∞–Ω–µ –Ω–∞ –≥—Ä–∞—Ñ–∏

### –ö–Ω–∏–≥–∏ –∏ –ú–∞—Ç–µ—Ä–∏–∞–ª–∏

- "Introduction to Algorithms" (CLRS) - –ì–ª–∞–≤–∞ 22
- "Competitive Programming 3" - –ì–ª–∞–≤–∞ 4: Graphs
- [CP-Algorithms](https://cp-algorithms.com/graph/breadth-first-search.html) - –û–Ω–ª–∞–π–Ω —Ä–µ—Å—É—Ä—Å

---

**–ó–∞–±–µ–ª–µ–∂–∫–∏ –∑–∞ –û—Ü–µ–Ω—è–≤–∞–Ω–µ:**
- –ó–∞–¥–∞—á–∏ 1-5: –¢–µ—Å—Ç–≤–∞—Ç –æ—Å–Ω–æ–≤–Ω–æ —Ä–∞–∑–±–∏—Ä–∞–Ω–µ –∏ —Ç–µ—Ä–º–∏–Ω–æ–ª–æ–≥–∏—è
- –ó–∞–¥–∞—á–∏ 6-10: –ü—Ä–æ–≤–µ—Ä—è–≤–∞—Ç —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—Ç–∞ –∑–∞ —á–µ—Ç–µ–Ω–µ –∏ –ø—Ä–æ—Å–ª–µ–¥—è–≤–∞–Ω–µ –Ω–∞ –∫–æ–¥
- –ó–∞–¥–∞—á–∏ 11-14: –ü—Ä–∏–ª–∞–≥–∞—Ç –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏ –∑–∞ –∏–∑–±–æ—Ä –Ω–∞ –ø–æ–¥—Ö–æ–¥—è—â–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏
- –ó–∞–¥–∞—á–∏ 15-21: –°–∏–Ω—Ç–µ–∑–∏—Ä–∞—Ç –∑–Ω–∞–Ω–∏—è –∑–∞ —Ä–µ—à–∞–≤–∞–Ω–µ –Ω–∞ —Å–ª–æ–∂–Ω–∏ –ø—Ä–æ–±–ª–µ–º–∏
