<!DOCTYPE html>
<html lang="bg">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ì—Ä–∞—Ñ–∏ - –ü—Ä–µ–¥—Å—Ç–∞–≤—è–Ω–µ –∏ –û—Å–Ω–æ–≤–Ω–∏ –ê–ª–≥–æ—Ä–∏—Ç–º–∏ - FMI SDP</title>

    <!-- Reveal.js Core -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@5.0.4/dist/reveal.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@5.0.4/dist/theme/white.css">

    <!-- Code Highlighting - using highlight.js directly -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">

    <!-- Custom FMI Styles -->
    <style>
        .reveal .slides {
            text-align: left;
        }
        .reveal h1 {
            font-size: 2.2em;
            text-transform: none;
        }
        .reveal h2 {
            font-size: 1.8em;
            text-transform: none;
        }
        .reveal h3 {
            font-size: 1.4em;
            text-transform: none;
        }
        .reveal p, .reveal li {
            font-size: 0.85em;
            line-height: 1.4;
        }
        .reveal pre code {
            max-height: 500px;
            font-size: 0.75em;
        }
        .reveal code {
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
        }
        .reveal {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            font-size: 32px;
        }
        .reveal ul, .reveal ol {
            margin-left: 1em;
        }
        .reveal li {
            margin-bottom: 0.4em;
        }
        .reveal table {
            font-size: 0.8em;
        }
        .reveal img {
            max-width: 70%;
            max-height: 400px;
            margin: 0.5em auto;
            display: block;
            object-fit: contain;
        }
        /* Two-column layout */
        .reveal .columns {
            display: flex;
            gap: 2em;
            align-items: center;
        }
        .reveal .column {
            flex: 1;
        }
        .reveal .column img {
            max-width: 100%;
            max-height: 450px;
            margin: 0;
        }
        .reveal .column.left {
            text-align: left;
        }
        .reveal .column.right {
            text-align: center;
        }
        /* Back to lecture button */
        .back-button {
            position: fixed;
            bottom: 10px;
            left: 10px;
            z-index: 100;
            font-size: 14px;
            color: #666;
            text-decoration: none;
            background: rgba(255,255,255,0.9);
            padding: 5px 10px;
            border-radius: 5px;
            border: 1px solid #ddd;
            transition: all 0.2s;
        }
        .back-button:hover {
            background: rgba(255,255,255,1);
            color: #333;
            border-color: #999;
        }
    </style>
</head>
<body>
    <div class="reveal">
        <div class="slides">
            <section data-markdown>
<script type="text/template">
# üåê Graphs

## –ü—Ä–µ–¥—Å—Ç–∞–≤—è–Ω–µ –∏ –ê–ª–≥–æ—Ä–∏—Ç–º–∏

**–õ–µ–∫—Ü–∏—è 13** ‚Ä¢ –°—Ç—Ä—É–∫—Ç—É—Ä–∏ –æ—Ç –î–∞–Ω–Ω–∏ –∏ –ü—Ä–æ–≥—Ä–∞–º–∏—Ä–∞–Ω–µ
</script>
</section>
<section data-markdown>
<script type="text/template">
## üìã –°—ä–¥—ä—Ä–∂–∞–Ω–∏–µ

üéØ **Graph Terminology**

üìä **Graph Representations**

üîç **BFS - Breadth-First Search**

üå≤ **DFS - Depth-First Search**

üí° **Applications**

Note:
–ì—Ä–∞—Ñ–∏—Ç–µ —Å–∞ –Ω–∞–π-–æ–±—â–∞—Ç–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –æ—Ç –¥–∞–Ω–Ω–∏ - –º–æ–¥–µ–ª–∏—Ä–∞—Ç –≤—Ä—ä–∑–∫–∏!
</script>
</section>
<section data-background="#e7f3ff" data-markdown>
<script type="text/template">
# üéØ –ß–∞—Å—Ç 1

## Graph Basics
</script>
</section>
<section data-markdown>
<script type="text/template">
## –ö–∞–∫–≤–æ –µ Graph?

**–î–µ—Ñ–∏–Ω–∏—Ü–∏—è:** G = (V, E)
- **V** = Vertices (–≤—ä—Ä—Ö–æ–≤–µ/nodes)
- **E** = Edges (—Ä–µ–±—Ä–∞/–≤—Ä—ä–∑–∫–∏)

```
–ü—Ä–∏–º–µ—Ä:
V = {A, B, C, D}
E = {(A,B), (A,C), (B,D), (C,D)}

    A ---- B
    |      |
    C ---- D
```

Note:
–ì—Ä–∞—Ñ–∏—Ç–µ –º–æ–¥–µ–ª–∏—Ä–∞—Ç –≤—Ä—ä–∑–∫–∏ –º–µ–∂–¥—É –æ–±–µ–∫—Ç–∏!
</script>
</section>
<section data-markdown>
<script type="text/template">
## –¢–∏–ø–æ–≤–µ –ì—Ä–∞—Ñ–∏

<div class="columns">
<div class="column left">

**Undirected (–ù–µ–Ω–∞—Å–æ—á–µ–Ω):**
```
A ---- B
```
- –ü—Ä–∏—è—Ç–µ–ª—Å—Ç–≤–∞ –≤ Facebook
- –î–≤—É–ø–æ—Å–æ—á–Ω–∞ –≤—Ä—ä–∑–∫–∞

**Unweighted:**
```
A ---- B
```
- –í—Å–∏—á–∫–∏ —Ä–µ–±—Ä–∞ —Ä–∞–≤–Ω–∏

</div>
<div class="column right">

**Directed (–ù–∞—Å–æ—á–µ–Ω):**
```
A --‚Üí B
```
- Follows –≤ Twitter
- –ï–¥–Ω–æ–ø–æ—Å–æ—á–Ω–∞ –≤—Ä—ä–∑–∫–∞

**Weighted:**
```
A --5-- B
```
- –†–∞–∑—Å—Ç–æ—è–Ω–∏—è, —Ü–µ–Ω–∏

</div>
</div>

Note:
–ò–∑–±–æ—Ä—ä—Ç –Ω–∞ —Ç–∏–ø –≥—Ä–∞—Ñ –∑–∞–≤–∏—Å–∏ –æ—Ç –º–æ–¥–µ–ª–∏—Ä–∞–Ω–∞—Ç–∞ —Å–∏—Å—Ç–µ–º–∞!
</script>
</section>
<section data-markdown>
<script type="text/template">
## Graph Terminology

**Degree:** –ë—Ä–æ–π —Ä–µ–±—Ä–∞ —Å–≤—ä—Ä–∑–∞–Ω–∏ –∫—ä–º –≤—Ä—ä—Ö
- **Undirected:** degree(v)
- **Directed:** in-degree(v) + out-degree(v)

**Path:** –ü–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª–Ω–æ—Å—Ç –æ—Ç –≤—ä—Ä—Ö–æ–≤–µ
- Simple path: –±–µ–∑ –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏—è

**Cycle:** Path –∑–∞–ø–æ—á–≤–∞—â –∏ –∑–∞–≤—ä—Ä—à–≤–∞—â –≤ —Å—ä—â–∏—è –≤—Ä—ä—Ö

**Connected:** –ò–º–∞ –ø—ä—Ç –º–µ–∂–¥—É –≤—Å–µ–∫–∏ –¥–≤–µ —Ç–æ—á–∫–∏

Note:
–¢–µ–∑–∏ —Ç–µ—Ä–º–∏–Ω–∏ —Å–∞ —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª–Ω–∏ –∑–∞ graph –∞–ª–≥–æ—Ä–∏—Ç–º–∏—Ç–µ!
</script>
</section>
<section data-background="#e8f5e9" data-markdown>
<script type="text/template">
# –ß–∞—Å—Ç 2

## Graph Representations
</script>
</section>
<section data-markdown>
<script type="text/template">
## Adjacency Matrix

**2D Array:** matrix[i][j] = 1 –∞–∫–æ –∏–º–∞ —Ä–µ–±—Ä–æ –æ—Ç i –¥–æ j

```
Graph:       Matrix:
A--B           A B C D
|  |         A[0 1 1 0]
C--D         B[1 0 0 1]
             C[1 0 0 1]
             D[0 1 1 0]
```

**Implementation:**
```cpp
class Graph {
    int V;  // –ë—Ä–æ–π –≤—ä—Ä—Ö–æ–≤–µ
    vector<vector<int>> adj;

public:
    Graph(int vertices) : V(vertices) {
        adj.resize(V, vector<int>(V, 0));
    }

    void addEdge(int u, int v) {
        adj[u][v] = 1;
        adj[v][u] = 1;  // Undirected
    }

    bool hasEdge(int u, int v) {
        return adj[u][v] == 1;
    }
};
```

Note:
Adjacency matrix –µ –ø—Ä–æ—Å—Ç, –Ω–æ –∏–∑–ø–æ–ª–∑–≤–∞ O(V¬≤) –ø–∞–º–µ—Ç!
</script>
</section>
<section data-markdown>
<script type="text/template">
## Adjacency List

**Array of Lists:** list[i] —Å—ä–¥—ä—Ä–∂–∞ –≤—Å–∏—á–∫–∏ —Å—ä—Å–µ–¥–∏ –Ω–∞ i

```
Graph:       List:
A--B         A: [B, C]
|  |         B: [A, D]
C--D         C: [A, D]
             D: [B, C]
```

**Implementation:**
```cpp
class Graph {
    int V;
    vector<list<int>> adj;

public:
    Graph(int vertices) : V(vertices) {
        adj.resize(V);
    }

    void addEdge(int u, int v) {
        adj[u].push_back(v);
        adj[v].push_back(u);  // Undirected
    }

    // –û–±—Ö–æ–∂–¥–∞–Ω–µ –Ω–∞ —Å—ä—Å–µ–¥–∏
    void printNeighbors(int v) {
        for (int neighbor : adj[v]) {
            cout << neighbor << " ";
        }
    }
};
```

Note:
Adjacency list –µ –µ—Ñ–µ–∫—Ç–∏–≤–Ω–∞ –∑–∞ —Ä–∞–∑—Ä–µ–¥–µ–Ω–∏ –≥—Ä–∞—Ñ–∏!
</script>
</section>
<section data-markdown>
<script type="text/template">
## Matrix vs List

| –•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∞ | Matrix | List |
|----------------|--------|------|
| **–ü–∞–º–µ—Ç** | O(V¬≤) | O(V + E) |
| **–ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞ —Ä–µ–±—Ä–æ** | O(1) | O(degree) |
| **–û–±—Ö–æ–∂–¥–∞–Ω–µ –Ω–∞ —Å—ä—Å–µ–¥–∏** | O(V) | O(degree) |
| **–î–æ–±–∞–≤—è–Ω–µ –Ω–∞ —Ä–µ–±—Ä–æ** | O(1) | O(1) |
| **Best for** | –ü–ª—ä—Ç–Ω–∏ –≥—Ä–∞—Ñ–∏ | –†–∞–∑—Ä–µ–¥–µ–Ω–∏ –≥—Ä–∞—Ñ–∏ |

Note:
–ò–∑–±–æ—Ä—ä—Ç –∑–∞–≤–∏—Å–∏ –æ—Ç –ø–ª—ä—Ç–Ω–æ—Å—Ç—Ç–∞ –Ω–∞ –≥—Ä–∞—Ñ–∞!
</script>
</section>
<section data-background="#fff3e0" data-markdown>
<script type="text/template">
# –ß–∞—Å—Ç 3

## BFS - Breadth-First Search
</script>
</section>
<section data-markdown>
<script type="text/template">
## BFS Algorithm

**–ò–¥–µ—è:** –û–±—Ö–æ–∂–¥–∞–Ω–µ –Ω–∏–≤–æ –ø–æ –Ω–∏–≤–æ —Å queue

```cpp
void BFS(int start) {
    vector<bool> visited(V, false);
    queue<int> q;

    visited[start] = true;
    q.push(start);

    while (!q.empty()) {
        int v = q.front();
        q.pop();
        cout << v << " ";

        // –û–±—Ö–æ–¥–∏ –≤—Å–∏—á–∫–∏ —Å—ä—Å–µ–¥–∏
        for (int neighbor : adj[v]) {
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                q.push(neighbor);
            }
        }
    }
}
```

**Complexity: O(V + E)**

Note:
BFS –∏–∑–ø–æ–ª–∑–≤–∞ queue –∑–∞ –æ–±—Ö–æ–∂–¥–∞–Ω–µ –ø–æ –Ω–∏–≤–∞!
</script>
</section>
<section data-markdown>
<script type="text/template">
## BFS Example

```
Graph:
    0
   / \
  1   2
 / \   \
3   4   5

BFS –æ—Ç 0:
–ù–∏–≤–æ 0: 0
–ù–∏–≤–æ 1: 1, 2
–ù–∏–≤–æ 2: 3, 4, 5

Output: 0 1 2 3 4 5

Queue changes:
[0]
[1, 2]
[2, 3, 4]
[3, 4, 5]
...
```

Note:
BFS –æ–±—Ö–æ–∂–¥–∞ –≤—Å–∏—á–∫–∏ –≤—ä—Ä—Ö–æ–≤–µ –Ω–∞ –Ω–∏–≤–æ –ø—Ä–µ–¥–∏ –¥–∞ –ø—Ä–µ–º–∏–Ω–µ –Ω–∞ —Å–ª–µ–¥–≤–∞—â–æ—Ç–æ!
</script>
</section>
<section data-markdown>
<script type="text/template">
## BFS Applications

**Shortest Path (unweighted):**
```cpp
vector<int> BFS_shortest_path(int start, int end) {
    vector<int> parent(V, -1);
    queue<int> q;
    q.push(start);
    parent[start] = start;

    while (!q.empty()) {
        int v = q.front(); q.pop();
        if (v == end) break;

        for (int neighbor : adj[v]) {
            if (parent[neighbor] == -1) {
                parent[neighbor] = v;
                q.push(neighbor);
            }
        }
    }

    // Reconstruct path
    vector<int> path;
    for (int v = end; v != start; v = parent[v])
        path.push_back(v);
    path.push_back(start);
    reverse(path.begin(), path.end());
    return path;
}
```

Note:
BFS –Ω–∞–º–∏—Ä–∞ –Ω–∞–π-–∫—Ä–∞—Ç–∫–∏—è –ø—ä—Ç –≤ –Ω–µ—Ç–µ–≥–ª–µ–Ω –≥—Ä–∞—Ñ!
</script>
</section>
<section data-background="#f3e5f5" data-markdown>
<script type="text/template">
# –ß–∞—Å—Ç 4

## DFS - Depth-First Search
</script>
</section>
<section data-markdown>
<script type="text/template">
## DFS Algorithm

**–ò–¥–µ—è:** –û–±—Ö–æ–∂–¥–∞–Ω–µ –≤ –¥—ä–ª–±–æ—á–∏–Ω–∞ —Å—ä—Å stack/recursion

```cpp
void DFS(int v, vector<bool>& visited) {
    visited[v] = true;
    cout << v << " ";

    for (int neighbor : adj[v]) {
        if (!visited[neighbor]) {
            DFS(neighbor, visited);
        }
    }
}

void startDFS(int start) {
    vector<bool> visited(V, false);
    DFS(start, visited);
}
```

**Complexity: O(V + E)**

Note:
DFS –∏–∑–ø–æ–ª–∑–≤–∞ recursion (stack) –∑–∞ –æ–±—Ö–æ–∂–¥–∞–Ω–µ –≤ –¥—ä–ª–±–æ—á–∏–Ω–∞!
</script>
</section>
<section data-markdown>
<script type="text/template">
## DFS Example

```
Graph:
    0
   / \
  1   2
 / \   \
3   4   5

DFS –æ—Ç 0:
0 ‚Üí 1 ‚Üí 3 (backtrack)
    ‚Üí 4 (backtrack)
  ‚Üí 2 ‚Üí 5

Output: 0 1 3 4 2 5

Call Stack:
DFS(0)
  DFS(1)
    DFS(3)
    DFS(4)
  DFS(2)
    DFS(5)
```

Note:
DFS –æ—Ç–∏–≤–∞ –º–∞–∫—Å–∏–º–∞–ª–Ω–æ –Ω–∞–¥—ä–ª–±–æ–∫–æ –ø—Ä–µ–¥–∏ –¥–∞ backtrack!
</script>
</section>
<section data-markdown>
<script type="text/template">
## DFS Applications

**Cycle Detection:**
```cpp
bool hasCycle(int v, vector<bool>& visited, int parent) {
    visited[v] = true;

    for (int neighbor : adj[v]) {
        if (!visited[neighbor]) {
            if (hasCycle(neighbor, visited, v))
                return true;
        }
        else if (neighbor != parent) {
            return true;  // Back edge ‚Üí cycle
        }
    }
    return false;
}
```

**–î—Ä—É–≥–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è:**
- Topological sorting
- Connected components
- Path finding
- Maze solving

Note:
DFS –µ –º–æ—â–µ–Ω –∑–∞ –æ—Ç–∫—Ä–∏–≤–∞–Ω–µ –Ω–∞ —Ü–∏–∫–ª–∏ –∏ —Å–≤—ä—Ä–∑–∞–Ω–æ—Å—Ç!
</script>
</section>
<section data-markdown>
<script type="text/template">
## BFS vs DFS

| –•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∞ | BFS | DFS |
|----------------|-----|-----|
| **–°—Ç—Ä—É–∫—Ç—É—Ä–∞** | Queue | Stack/Recursion |
| **–û–±—Ö–æ–∂–¥–∞–Ω–µ** | –ü–æ –Ω–∏–≤–∞ | –í –¥—ä–ª–±–æ—á–∏–Ω–∞ |
| **Shortest path** | ‚úÖ –ù–∞–º–∏—Ä–∞ | ‚ùå –ù–µ –≥–∞—Ä–∞–Ω—Ç–∏—Ä–∞ |
| **Memory** | O(V) | O(h) |
| **Use case** | Shortest path, –±–ª–∏–∑–∫–∏  nodes | Cycle detection, paths |

Note:
–ò–∑–±–æ—Ä—ä—Ç –º–µ–∂–¥—É BFS –∏ DFS –∑–∞–≤–∏—Å–∏ –æ—Ç –∑–∞–¥–∞—á–∞—Ç–∞!
</script>
</section>
<section data-background="#e0f2f1" data-markdown>
<script type="text/template">
# –ß–∞—Å—Ç 5

## Real-World Applications
</script>
</section>
<section data-markdown>
<script type="text/template">
## Social Networks

```cpp
// –ù–∞–º–µ—Ä–∏ mutual friends
set<int> mutualFriends(int user1, int user2) {
    set<int> friends1(adj[user1].begin(),
                      adj[user1].end());
    set<int> friends2(adj[user2].begin(),
                      adj[user2].end());

    set<int> mutual;
    set_intersection(friends1.begin(), friends1.end(),
                    friends2.begin(), friends2.end(),
                    inserter(mutual, mutual.begin()));
    return mutual;
}
```

**–î—Ä—É–≥–∏:**
- Friend recommendations
- Community detection
- –í–ª–∏—è–Ω–∏–µ –∏ –ø–æ–ø—É–ª—è—Ä–Ω–æ—Å—Ç

Note:
–ì—Ä–∞—Ñ–∏—Ç–µ —Å–∞ –ø–µ—Ä—Ñ–µ–∫—Ç–Ω–∏ –∑–∞ –º–æ–¥–µ–ª–∏—Ä–∞–Ω–µ –Ω–∞ —Å–æ—Ü–∏–∞–ª–Ω–∏ –º—Ä–µ–∂–∏!
</script>
</section>
<section data-markdown>
<script type="text/template">
## Navigation Systems

**Shortest Path (Dijkstra's Algorithm):**
```cpp
// Weighted graph - –Ω–∞–π-–∫—ä—Å –ø—ä—Ç
vector<int> dijkstra(int start, int end) {
    priority_queue<pair<int,int>> pq;
    vector<int> dist(V, INT_MAX);
    vector<int> parent(V, -1);

    dist[start] = 0;
    pq.push({0, start});

    while (!pq.empty()) {
        int u = pq.top().second;
        pq.pop();

        for (auto [v, weight] : adj[u]) {
            if (dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
                parent[v] = u;
                pq.push({-dist[v], v});
            }
        }
    }
    // Reconstruct path...
}
```

Note:
GPS —Å–∏—Å—Ç–µ–º–∏—Ç–µ –∏–∑–ø–æ–ª–∑–≤–∞—Ç graph –∞–ª–≥–æ—Ä–∏—Ç–º–∏ –∑–∞ –Ω–∞–≤–∏–≥–∞—Ü–∏—è!
</script>
</section>
<section data-background="#e8eaf6" data-markdown>
<script type="text/template">
# –û–±–æ–±—â–µ–Ω–∏–µ
</script>
</section>
<section data-markdown>
<script type="text/template">
## –ö–ª—é—á–æ–≤–∏ –ò–∑–≤–æ–¥–∏

**Graph Representations:**
- Adjacency Matrix: O(V¬≤) –ø–∞–º–µ—Ç, O(1) –ø—Ä–æ–≤–µ—Ä–∫–∞
- Adjacency List: O(V+E) –ø–∞–º–µ—Ç, –µ—Ñ–µ–∫—Ç–∏–≤–Ω–æ –æ–±—Ö–æ–∂–¥–∞–Ω–µ

**BFS:**
- –û–±—Ö–æ–∂–¥–∞–Ω–µ –ø–æ –Ω–∏–≤–∞ —Å queue
- –ù–∞–º–∏—Ä–∞ shortest path –≤ unweighted graph
- O(V + E) complexity

**DFS:**
- –û–±—Ö–æ–∂–¥–∞–Ω–µ –≤ –¥—ä–ª–±–æ—á–∏–Ω–∞ —Å recursion
- –û—Ç–∫—Ä–∏–≤–∞ —Ü–∏–∫–ª–∏ –∏ connected components
- O(V + E) complexity

Note:
–ì—Ä–∞—Ñ–∏—Ç–µ —Å–∞ –º–æ—â–Ω–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –∑–∞ –º–æ–¥–µ–ª–∏—Ä–∞–Ω–µ –Ω–∞ —Å–ª–æ–∂–Ω–∏ –≤—Ä—ä–∑–∫–∏!
</script>
</section>
<section data-markdown>
<script type="text/template">
## –ó–∞ –ò–∑–ø–∏—Ç–∞

‚úÖ **Graph terminology** - degree, path, cycle

‚úÖ **Representations** - matrix vs list trade-offs

‚úÖ **BFS vs DFS** - –∫–æ–≥–∞ –∫–∞–∫—ä–≤ –¥–∞ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ

‚úÖ **Complexity** - O(V + E) –∑–∞ –∏ –¥–≤–∞—Ç–∞

‚úÖ **Applications** - shortest path, cycle detection

Note:
–¢–µ–∑–∏ –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏ —Å–∞ —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª–Ω–∏ –∑–∞ graph –∞–ª–≥–æ—Ä–∏—Ç–º–∏—Ç–µ!
</script>
</section>
<section data-markdown>
<script type="text/template">
## STL for Graphs

```cpp
// Adjacency list
vector<vector<int>> adj;

// Weighted graph
vector<vector<pair<int, int>>> adj;  // {neighbor, weight}

// Set for fast lookup
vector<set<int>> adj;

// Unordered for O(1) average
vector<unordered_set<int>> adj;
```

Note:
–ò–∑–ø–æ–ª–∑–≤–∞–π—Ç–µ STL –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∏—Ç–µ –∑–∞ –µ—Ñ–µ–∫—Ç–∏–≤–Ω–∞ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏—è!
</script>
</section>
<section data-markdown>
<script type="text/template">
## –î–æ–ø—ä–ª–Ω–∏—Ç–µ–ª–Ω–∏ –†–µ—Å—É—Ä—Å–∏

**Graphs:**
- [Graph Data Structure - GeeksforGeeks](https://www.geeksforgeeks.org/graph-data-structure-and-algorithms/)
- [BFS and DFS](https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/)

**Visualizations:**
- [Graph Algorithms Visualization](https://visualgo.net/en/dfsbfs)

**Practice:**
- [LeetCode - Graph Problems](https://leetcode.com/tag/graph/)

Note:
–ü—Ä–∞–∫—Ç–∏–∫–∞—Ç–∞ –µ –∫–ª—é—á–æ–≤–∞ - —Ä–µ—à–∞–≤–∞–π—Ç–µ graph –∑–∞–¥–∞—á–∏!
</script>
</section>
<section data-background="#4caf50" data-markdown>
<script type="text/template">
# –ë–ª–∞–≥–æ–¥–∞—Ä—è –∑–∞ –í–Ω–∏–º–∞–Ω–∏–µ—Ç–æ!

## –í—ä–ø—Ä–æ—Å–∏? üéì

**–°–ª–µ–¥–≤–∞—â–∞ –ª–µ–∫—Ü–∏—è:** Sorting Algorithms

Note:
–í—Ä–µ–º–µ –∑–∞ –≤—ä–ø—Ä–æ—Å–∏!
</script>
</section>

        </div>
    </div>

    <!-- Navigation Helper -->
    <a href="/fmi-sdp-exc-2025-26/docs/graphs/lecture" class="back-button">
        ‚Üê Back to Lecture
    </a>

    <!-- Reveal.js Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@5.0.4/dist/reveal.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@5.0.4/plugin/notes/notes.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@5.0.4/plugin/markdown/markdown.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@5.0.4/plugin/highlight/highlight.js"></script>

    <!-- marked library required by reveal.js markdown plugin -->
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.0/marked.min.js"></script>

    <script>
        Reveal.initialize({
            hash: true,
            history: true,
            slideNumber: 'c/t',
            showSlideNumber: 'all',
            transition: 'slide',
            controls: true,
            progress: true,
            center: true,
            width: 1280,
            height: 720,
            margin: 0.04,
            plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ],
            markdown: {
                smartypants: false,
                gfm: true,
                breaks: false,
                pedantic: false,
                sanitize: false,
                smartLists: true
            },
            highlight: {
                highlightOnLoad: true,
                escapeHTML: false
            }
        });
    </script>
</body>
</html>