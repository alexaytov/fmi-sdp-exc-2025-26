# Упражнения: Побитови операции в C++

## Ниво: ЛЕСНО (Основи и разбиране)

**Exercise 1 [EASY]**: Конвертирайте десетичното число 13 в двоична бройна система. Покажете стъпките на преобразуването.

**Exercise 2 [EASY]**: Какво е представянето на числото 127 в 8-битов unsigned char? Запишете резултата в двоична форма.

**Exercise 3 [EASY]**: Изберете правилния отговор: Каква е стойността на най-младшия бит (LSB) в числото 26?
- A) 0
- B) 1
- C) 2
- D) 13

**Exercise 4 [EASY]**: Колко различни стойности може да представи 16-битово число без знак?

**Exercise 5 [EASY]**: Каква е стойността на израза `7 & 5`? Покажете побитовата операция.

**Exercise 6 [EASY]**: Каква е стойността на израза `4 | 2`? Обяснете резултата с двоични числа.

**Exercise 7 [EASY]**: Изберете правилния отговор: Операторът `~` (NOT) върху числото 0 (в 8-битово представяне) дава:
- A) 0
- B) 1
- C) 255
- D) -1

**Exercise 8 [EASY]**: Какво прави операцията `x << 1` върху числото x? 
- A) Умножава по 2
- B) Дели на 2
- C) Добавя 1
- D) Изважда 1

## Ниво: СРЕДНО (Прилагане на концепции)

**Exercise 9 [MEDIUM]**: Напишете израз в C++, който проверява дали 3-тият бит (брои се от 0) на променлива `num` е установен (равен на 1).

**Exercise 10 [MEDIUM]**: Каква е стойността на израза `15 ^ 10`? Покажете побитовата операция и обяснете XOR оператора.

**Exercise 11 [MEDIUM]**: Напишете C++ код, който установява (прави равен на 1) 5-ия бит на променлива `flags`, без да променя останалите битове.

**Exercise 12 [MEDIUM]**: Дадена е променлива `int value = 80;`. Каква ще бъде стойността след `value >> 3`? Обяснете защо.

**Exercise 13 [MEDIUM]**: Напишете израз, който извлича последните 6 бита от променлива `data` използвайки битова маска.

**Exercise 14 [MEDIUM]**: Открийте грешката в следния код:
```cpp
int x = 10;
if (x & 2 == 2) {
    cout << "Bit 1 is set";
}
```

**Exercise 15 [MEDIUM]**: Каква е стойността на `~0` в 32-битов signed int? Обяснете резултата.

**Exercise 16 [MEDIUM]**: Напишете функция `bool isPowerOfTwo(int n)`, която проверява дали числото n е степен на 2, използвайки побитови операции.

## Ниво: СРЕДНО-ТРУДНО (Комбинирани операции)

**Exercise 17 [MEDIUM-HARD]**: Напишете C++ функция, която нулира (прави равен на 0) определен бит на позиция `pos` в числото `num`.
```cpp
unsigned int clearBit(unsigned int num, int pos) {
    // Вашият код тук
}
```

**Exercise 18 [MEDIUM-HARD]**: Даден е следният код за управление на разрешения:
```cpp
#define READ    0b001
#define WRITE   0b010
#define EXECUTE 0b100

unsigned char permissions = READ | EXECUTE;
```
Напишете код, който:
1. Проверява дали има WRITE разрешение
2. Добавя WRITE разрешение
3. Премахва READ разрешение

**Exercise 19 [MEDIUM-HARD]**: Дадено е 32-битово RGB число `0x00FF8040` (формат: 0x00RRGGBB). Напишете функции, които извличат стойностите на червения, зеления и синия компонент.

**Exercise 20 [MEDIUM-HARD]**: Напишете функция `int countSetBits(unsigned int n)`, която брои колко бита са установени (равни на 1) в числото n. Използвайте техниката `n & (n-1)`.

## Ниво: ТРУДНО (Напреднали приложения)

**Exercise 21 [HARD]**: Напишете функция `void swapBits(unsigned int &num, int pos1, int pos2)`, която разменя битовете на позиции pos1 и pos2 в числото num.

**Exercise 22 [HARD]**: Имплементирайте функция за прост XOR криптиране/декриптиране:
```cpp
void xorCipher(char* data, int length, char key) {
    // Вашият код тук
}
```
Обяснете защо същата функция работи и за криптиране, и за декриптиране.

**Exercise 23 [HARD]**: Напишете функция `unsigned int reverseBits(unsigned int num)`, която обръща реда на всички битове в 32-битово число (първият става последен и обратно).

**Exercise 24 [HARD]**: Имплементирайте функция, която изчислява `x * y` използвайки САМО побитови операции (без аритметични оператори `*`, `+`, `-`).

**Exercise 25 [HARD]**: Създайте клас `BitSet`, който съхранява до 32 булеви флага в един unsigned int и предоставя методи:
- `void set(int pos)` - установява бит
- `void clear(int pos)` - нулира бит
- `bool test(int pos)` - проверява бит
- `void toggle(int pos)` - инвертира бит
- `int count()` - брои установени битове

**Exercise 26 [HARD]**: Анализирайте следния код и обяснете какво прави:
```cpp
unsigned int x = 42;
x = x & (x - 1);
```
При какви случаи този трик е полезен? Напишете програма, която използва този подход за решаване на практическа задача.

**Exercise 27 [HARD]**: Напишете функция `int getLowestSetBit(unsigned int n)`, която връща позицията на най-младшия установен бит. Използвайте техниката `x & -x`. Обяснете как работи тази техника със signed numbers и two's complement.

**Exercise 28 [HARD]**: Оптимизирайте следния код използвайки побитови операции:
```cpp
int result = 0;
if (value % 16 == 0) {
    result = value / 8;
} else {
    result = (value / 4) * 3;
}
```

**Exercise 29 [HARD]**: Дебъгване и анализ: Обяснете какво е грешно в следния код и как да го поправите:
```cpp
int setBits(int num, int start, int end) {
    int mask = (1 << (end - start + 1)) - 1;
    return num | mask << start;
}
```
Тествайте с `setBits(0, 2, 5)` и обяснете неочаквания резултат.

**Exercise 30 [HARD]**: Проектна задача: Създайте система за компресия на boolean масив. Вместо да използвате `bool array[100]` (100 байта), използвайте побитови операции за да съхраните същата информация в `unsigned int array[4]` (16 байта). Имплементирайте:
- `void setBool(unsigned int* arr, int index, bool value)`
- `bool getBool(unsigned int* arr, int index)`
- Изчислете процента на спестена памет

---

**Забележка за преподавателя**: Упражненията са организирани така, че постепенно да изграждат умения - от основно разбиране на концепциите до сложни реални приложения. Препоръчително е студентите да решават задачите последователно и да проверяват решенията си с примерен код.