<!DOCTYPE html>
<html lang="bg">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Упражнения: Линейни Структури от Данни и Масиви</title>
    <link rel="stylesheet" href="exercises-styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <!-- Highlight.js for syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/cpp.min.js"></script>
</head>
<body>
    <!-- Hero Section -->
    <div class="hero">
        <div class="hero-content">
            <div class="meta-badges">
                <span class="badge badge-exercises">Упражнения</span>
                <span class="badge badge-count">30 Задачи</span>
                <span class="badge badge-language">C++</span>
            </div>
            <h1>Упражнения: Линейни Структури от Данни</h1>
            <p class="subtitle">Масиви, Обектно-Ориентирана Реализация и Двоично Търсене в C++</p>
        </div>
    </div>

    <!-- Progress Bar -->
    <div class="progress-container">
        <div class="progress-stats">
            <span id="completed-count">0</span> / <span id="total-count">30</span> упражнения завършени
            (<span id="progress-percent">0</span>%)
        </div>
        <div class="progress-bar">
            <div class="progress-fill" id="progress-fill"></div>
        </div>
    </div>

    <!-- Navigation -->
    <nav class="sticky-nav">
        <div class="nav-content">
            <a href="#easy" class="nav-link">Лесни (1-10)</a>
            <a href="#medium" class="nav-link">Средни (11-20)</a>
            <a href="#hard" class="nav-link">Трудни (21-30)</a>
        </div>
    </nav>

    <!-- Main Content -->
    <main class="container">
        <!-- Easy Level -->
        <section id="easy" class="exercises-section">
            <h2>Лесно Ниво (1-10)</h2>

            <div class="exercise-card">
                <div class="exercise-header">
                    <div class="exercise-title-group">
                        <input type="checkbox" class="exercise-checkbox" id="ex1">
                        <label for="ex1" class="exercise-number">Упражнение 1</label>
                    </div>
                    <span class="difficulty-badge easy">ЛЕСНО</span>
                </div>
                <div class="exercise-content">
                    <p><strong>Въпрос:</strong> Какво е структура от данни? С ваши думи, обяснете защо изборът на правилната структура от данни има значение в програмирането.</p>
                    <div class="answer-section">
                        <button class="answer-btn">Покажи Отговор ↓</button>
                        <div class="answer-content">
                            <p><strong>Отговор:</strong> Структурата от данни е организиран начин за съхранение и управление на данни в компютъра, който позволява ефективно извършване на операции като добавяне, изтриване, търсене и достъп до данни. Изборът на правилната структура има значение, защото:</p>
                            <ul>
                                <li><strong>Производителност:</strong> Различните структури имат различна времева сложност за операции (O(1), O(log n), O(n))</li>
                                <li><strong>Памет:</strong> Ефективното използване на паметта зависи от структурата</li>
                                <li><strong>Скалируемост:</strong> Правилният избор осигурява добра производителност при нарастване на данните</li>
                                <li><strong>Четимост:</strong> Подходящата структура прави кода по-разбираем и поддържаем</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

            <div class="exercise-card">
                <div class="exercise-header">
                    <div class="exercise-title-group">
                        <input type="checkbox" class="exercise-checkbox" id="ex2">
                        <label for="ex2" class="exercise-number">Упражнение 2</label>
                    </div>
                    <span class="difficulty-badge easy">ЛЕСНО</span>
                </div>
                <div class="exercise-content">
                    <p><strong>Вярно или Невярно:</strong> В масив всички елементи трябва да са от един и същи тип данни. Обяснете отговора си.</p>
                    <div class="answer-section">
                        <button class="answer-btn">Покажи Отговор ↓</button>
                        <div class="answer-content">
                            <p><strong>Отговор:</strong> <strong>Вярно.</strong> В масив всички елементи трябва да са от един и същи тип данни (хомогенни елементи). Това е фундаментално свойство на масивите, което позволява:</p>
                            <ul>
                                <li>Всеки елемент заема еднакво количество памет</li>
                                <li>Директното изчисляване на адреси: <code>адрес = база + (индекс × размер)</code></li>
                                <li>Константен O(1) достъп до всеки елемент по индекс</li>
                            </ul>
                            <p>Ако елементите бяха с различен размер, директното изчисляване на адреси нямаше да е възможно.</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="exercise-card">
                <div class="exercise-header">
                    <div class="exercise-title-group">
                        <input type="checkbox" class="exercise-checkbox" id="ex3">
                        <label for="ex3" class="exercise-number">Упражнение 3</label>
                    </div>
                    <span class="difficulty-badge easy">ЛЕСНО</span>
                </div>
                <div class="exercise-content">
                    <p><strong>Задача:</strong> Даден е масивът <code>int numbers[5] = {10, 20, 30, 40, 50};</code>, каква е стойността на <code>numbers[2]</code>?</p>
                    <div class="answer-section">
                        <button class="answer-btn">Покажи Отговор ↓</button>
                        <div class="answer-content">
                            <p><strong>Отговор:</strong> <code>numbers[2] = 30</code></p>
                            <p><strong>Обяснение:</strong> Масивите в C++ (и повечето програмни езици) използват индексиране, базирано на нула:</p>
                            <ul>
                                <li><code>numbers[0] = 10</code> (първи елемент)</li>
                                <li><code>numbers[1] = 20</code> (втори елемент)</li>
                                <li><code>numbers[2] = 30</code> (трети елемент) ← Търсеният отговор</li>
                                <li><code>numbers[3] = 40</code> (четвърти елемент)</li>
                                <li><code>numbers[4] = 50</code> (пети елемент)</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

            <div class="exercise-card">
                <div class="exercise-header">
                    <div class="exercise-title-group">
                        <input type="checkbox" class="exercise-checkbox" id="ex4">
                        <label for="ex4" class="exercise-number">Упражнение 4</label>
                    </div>
                    <span class="difficulty-badge easy">ЛЕСНО</span>
                </div>
                <div class="exercise-content">
                    <p><strong>Въпрос:</strong> Какво означава "непрекъснато разпределение на паметта" в контекста на масивите? Защо е това важно?</p>
                    <div class="answer-section">
                        <button class="answer-btn">Покажи Отговор ↓</button>
                        <div class="answer-content">
                            <p><strong>Отговор:</strong> Непрекъснато разпределение означава, че всички елементи на масива се съхраняват последователно в паметта, без пропуски между тях.</p>
                            <p><strong>Защо е важно:</strong></p>
                            <ul>
                                <li><strong>Бърз достъп:</strong> Позволява директно изчисляване на адрес на всеки елемент</li>
                                <li><strong>Кеш ефективност:</strong> Процесорът може да зарежда съседни елементи в кеша заедно</li>
                                <li><strong>Предсказуемост:</strong> Простота при управление на паметта</li>
                                <li><strong>Без фрагментация:</strong> Целият масив е в един непрекъснат блок</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

            <div class="exercise-card">
                <div class="exercise-header">
                    <div class="exercise-title-group">
                        <input type="checkbox" class="exercise-checkbox" id="ex5">
                        <label for="ex5" class="exercise-number">Упражнение 5</label>
                    </div>
                    <span class="difficulty-badge easy">ЛЕСНО</span>
                </div>
                <div class="exercise-content">
                    <p><strong>Въпрос:</strong> Ако създадете масив с <code>int grades[100];</code>, можете ли по-късно да промените размера му на 150 по време на изпълнението на програмата? Защо или защо не?</p>
                    <div class="answer-section">
                        <button class="answer-btn">Покажи Отговор ↓</button>
                        <div class="answer-content">
                            <p><strong>Отговор:</strong> <strong>НЕ</strong>, не можете да промените размера на статичен масив по време на изпълнение.</p>
                            <p><strong>Причини:</strong></p>
                            <ul>
                                <li>Статичните масиви имат <strong>фиксиран размер</strong>, определен при компилация</li>
                                <li>Паметта се заделя на стека и размерът е константа</li>
                                <li>След създаване, размерът не може да се променя</li>
                            </ul>
                            <p><strong>Алтернативи:</strong></p>
                            <ul>
                                <li>Използвайте динамично заделена памет (<code>new[]</code>) и пресъздайте масива</li>
                                <li>Използвайте <code>std::vector</code>, който автоматично управлява размера</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

            <div class="exercise-card">
                <div class="exercise-header">
                    <div class="exercise-title-group">
                        <input type="checkbox" class="exercise-checkbox" id="ex6">
                        <label for="ex6" class="exercise-number">Упражнение 6</label>
                    </div>
                    <span class="difficulty-badge easy">ЛЕСНО</span>
                </div>
                <div class="exercise-content">
                    <p><strong>Въпрос:</strong> Каква е времевата сложност (Big O нотация) за достъп до елемент в масив по неговия индекс? Обяснете защо.</p>
                    <div class="answer-section">
                        <button class="answer-btn">Покажи Отговор ↓</button>
                        <div class="answer-content">
                            <p><strong>Отговор:</strong> Времевата сложност е <strong>O(1)</strong> - константно време.</p>
                            <p><strong>Защо:</strong></p>
                            <ul>
                                <li>Адресът се изчислява директно по формулата: <code>адрес = база + (индекс × размер_елемент)</code></li>
                                <li>Не е необходимо да се обхожда масивът</li>
                                <li>Времето за достъп е <strong>независимо</strong> от размера на масива</li>
                                <li>Едно просто аритметично изчисление + един memory read</li>
                            </ul>
                            <p>Това е едно от най-големите предимства на масивите спрямо други структури като свързани списъци (O(n) достъп).</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="exercise-card">
                <div class="exercise-header">
                    <div class="exercise-title-group">
                        <input type="checkbox" class="exercise-checkbox" id="ex7">
                        <label for="ex7" class="exercise-number">Упражнение 7</label>
                    </div>
                    <span class="difficulty-badge easy">ЛЕСНО</span>
                </div>
                <div class="exercise-content">
                    <p><strong>Въпрос:</strong> В обектно-ориентираното програмиране, какво означава "инкапсулация"? Дайте пример, свързан с масиви.</p>
                    <div class="answer-section">
                        <button class="answer-btn">Покажи Отговор ↓</button>
                        <div class="answer-content">
                            <p><strong>Отговор:</strong> Инкапсулацията е принцип на ООП, при който данните (атрибути) и методите за работа с тях се обединяват в един клас, като вътрешните детайли се скриват от външния свят.</p>
                            <p><strong>Пример с масиви:</strong></p>
                            <pre><code class="language-cpp">class CustomArray {
private:
    int* data;      // Скрит - external code не може да достъпи директно
    size_t size;    // Скрит
    
public:
    int get(size_t i) {  // Контролиран достъп
        if (i < size) return data[i];
        throw std::out_of_range("Невалиден индекс");
    }
};</code></pre>
                            <p>Инкапсулацията защитава данните от некоректни операции (напр. достъп извън границите).</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="exercise-card">
                <div class="exercise-header">
                    <div class="exercise-title-group">
                        <input type="checkbox" class="exercise-checkbox" id="ex8">
                        <label for="ex8" class="exercise-number">Упражнение 8</label>
                    </div>
                    <span class="difficulty-badge easy">ЛЕСНО</span>
                </div>
                <div class="exercise-content">
                    <p><strong>Вярно или Невярно:</strong> Двоичното търсене работи както върху сортирани, така и върху несортирани масиви. Обяснете отговора си.</p>
                    <div class="answer-section">
                        <button class="answer-btn">Покажи Отговор ↓</button>
                        <div class="answer-content">
                            <p><strong>Отговор:</strong> <strong>НЕВЯРНО!</strong> Двоичното търсене работи <strong>САМО</strong> върху сортирани масиви.</p>
                            <p><strong>Защо:</strong></p>
                            <ul>
                                <li>Алгоритъмът разчита на факта, че елементите са подредени</li>
                                <li>Сравнението със среден елемент показва в коя половина е целевата стойност</li>
                                <li>Ако масивът не е сортиран, тази логика не работи - може да елиминираме половината, в която всъщност е елементът</li>
                            </ul>
                            <p>За несортирани масиви се използва <strong>линейно търсене</strong> (O(n)).</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="exercise-card">
                <div class="exercise-header">
                    <div class="exercise-title-group">
                        <input type="checkbox" class="exercise-checkbox" id="ex9">
                        <label for="ex9" class="exercise-number">Упражнение 9</label>
                    </div>
                    <span class="difficulty-badge easy">ЛЕСНО</span>
                </div>
                <div class="exercise-content">
                    <p><strong>Задача:</strong> В масива <code>{2, 4, 6, 8, 10, 12, 14}</code>, ако търсите стойността 10 използвайки двоично търсене, кой е първият среден индекс, който ще бъде проверен?</p>
                    <div class="answer-section">
                        <button class="answer-btn">Покажи Отговор ↓</button>
                        <div class="answer-content">
                            <p><strong>Отговор:</strong> Средният индекс е <strong>3</strong>.</p>
                            <p><strong>Изчисление:</strong></p>
                            <ul>
                                <li>Масивът има 7 елемента (индекси 0-6)</li>
                                <li><code>low = 0</code>, <code>high = 6</code></li>
                                <li><code>mid = low + (high - low) / 2 = 0 + (6 - 0) / 2 = 0 + 3 = 3</code></li>
                                <li>На индекс 3 е стойността 8</li>
                                <li>Тъй като 8 < 10, ще търсим в дясната половина след това</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

            <div class="exercise-card">
                <div class="exercise-header">
                    <div class="exercise-title-group">
                        <input type="checkbox" class="exercise-checkbox" id="ex10">
                        <label for="ex10" class="exercise-number">Упражнение 10</label>
                    </div>
                    <span class="difficulty-badge easy">ЛЕСНО</span>
                </div>
                <div class="exercise-content">
                    <p><strong>Въпрос:</strong> Каква е целта на конструктора в C++ клас?</p>
                    <div class="answer-section">
                        <button class="answer-btn">Покажи Отговор ↓</button>
                        <div class="answer-content">
                            <p><strong>Отговор:</strong> Конструкторът е специален метод, който се извиква автоматично при създаване на обект от класа. Неговите цели са:</p>
                            <ul>
                                <li><strong>Инициализация:</strong> Задава начални стойности на членовете на класа</li>
                                <li><strong>Заделяне на ресурси:</strong> Заделя динамична памет, отваря файлове и др.</li>
                                <li><strong>Валидация:</strong> Проверява входни параметри преди създаване на обекта</li>
                                <li><strong>Гарантира валидно състояние:</strong> Обектът е винаги в коректно състояние след създаването му</li>
                            </ul>
                            <p><strong>Пример:</strong></p>
                            <pre><code class="language-cpp">CustomArray(size_t n) : capacity(n) {
    data = new int[capacity];  // Заделя памет
}</code></pre>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Medium Level -->
        <section id="medium" class="exercises-section">
            <h2>Средно Ниво (11-20)</h2>

            <div class="exercise-card">
                <div class="exercise-header">
                    <div class="exercise-title-group">
                        <input type="checkbox" class="exercise-checkbox" id="ex11">
                        <label for="ex11" class="exercise-number">Упражнение 11</label>
                    </div>
                    <span class="difficulty-badge medium">СРЕДНО</span>
                </div>
                <div class="exercise-content">
                    <p><strong>Кодиране:</strong> Напишете C++ код за деклариране и инициализация на масив от 7 double стойности, представляващи дневни температури. Включете код за отпечатване на всички температури.</p>
                    <div class="answer-section">
                        <button class="answer-btn">Покажи Отговор ↓</button>
                        <div class="answer-content">
                            <pre><code class="language-cpp">#include <iostream>

int main() {
    // Деклариране и инициализация
    double temperatures[7] = {22.5, 24.0, 23.8, 21.2, 25.1, 26.3, 24.7};
    
    // Отпечатване на всички температури
    std::cout << "Дневни температури:" << std::endl;
    for (int i = 0; i < 7; ++i) {
        std::cout << "Ден " << (i + 1) << ": " 
                  << temperatures[i] << "°C" << std::endl;
    }
    
    return 0;
}</code></pre>
                        </div>
                    </div>
                </div>
            </div>

            <div class="exercise-card">
                <div class="exercise-header">
                    <div class="exercise-title-group">
                        <input type="checkbox" class="exercise-checkbox" id="ex12">
                        <label for="ex12" class="exercise-number">Упражнение 12</label>
                    </div>
                    <span class="difficulty-badge medium">СРЕДНО</span>
                </div>
                <div class="exercise-content">
                    <p><strong>Обяснение:</strong> Обяснете разликата между тези две декларации на масиви в C++:</p>
                    <pre><code class="language-cpp">int arr1[10];
int* arr2 = new int[10];</code></pre>
                    <p>Какви са последиците за управлението на паметта при всяка от тях?</p>
                    <div class="answer-section">
                        <button class="answer-btn">Покажи Отговор ↓</button>
                        <div class="answer-content">
                            <p><strong>Отговор:</strong></p>
                            <table>
                                <tr>
                                    <th>Аспект</th>
                                    <th><code>int arr1[10];</code></th>
                                    <th><code>int* arr2 = new int[10];</code></th>
                                </tr>
                                <tr>
                                    <td>Тип памет</td>
                                    <td>Стек</td>
                                    <td>Heap (купчина)</td>
                                </tr>
                                <tr>
                                    <td>Време на живот</td>
                                    <td>Автоматично - до края на scope</td>
                                    <td>Ръчно - до <code>delete[]</code></td>
                                </tr>
                                <tr>
                                    <td>Освобождаване</td>
                                    <td>Автоматично</td>
                                    <td>Трябва <code>delete[] arr2;</code></td>
                                </tr>
                                <tr>
                                    <td>Размер</td>
                                    <td>Фиксиран при компилация</td>
                                    <td>Може да е runtime променлива</td>
                                </tr>
                                <tr>
                                    <td>Риск</td>
                                    <td>Stack overflow при голям размер</td>
                                    <td>Memory leak ако забравите delete[]</td>
                                </tr>
                            </table>
                        </div>
                    </div>
                </div>
            </div>

            <div class="exercise-card">
                <div class="exercise-header">
                    <div class="exercise-title-group">
                        <input type="checkbox" class="exercise-checkbox" id="ex13">
                        <label for="ex13" class="exercise-number">Упражнение 13</label>
                    </div>
                    <span class="difficulty-badge medium">СРЕДНО</span>
                </div>
                <div class="exercise-content">
                    <p><strong>Изчисление:</strong> Дадена е формулата <code>адрес = базов_адрес + (индекс × размер_на_елемента)</code>, изчислете адреса на паметта на елемента с индекс 5 в масив от цели числа, ако базовият адрес е 1000 и всяко цяло число заема 4 байта.</p>
                    <div class="answer-section">
                        <button class="answer-btn">Покажи Отговор ↓</button>
                        <div class="answer-content">
                            <p><strong>Отговор:</strong></p>
                            <p><code>адрес = базов_адрес + (индекс × размер_на_елемента)</code></p>
                            <p><code>адрес = 1000 + (5 × 4)</code></p>
                            <p><code>адрес = 1000 + 20</code></p>
                            <p><code>адрес = <strong>1020</strong></code></p>
                            <p><strong>Обяснение:</strong> Елементът на индекс 5 е 6-ият елемент (индексите започват от 0). Той е отместен с 5 × 4 = 20 байта от началото на масива.</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="exercise-card">
                <div class="exercise-header">
                    <div class="exercise-title-group">
                        <input type="checkbox" class="exercise-checkbox" id="ex14">
                        <label for="ex14" class="exercise-number">Упражнение 14</label>
                    </div>
                    <span class="difficulty-badge medium">СРЕДНО</span>
                </div>
                <div class="exercise-content">
                    <p><strong>Въпрос:</strong> В custom array клас, защо е важно да се имплементира проверка на границите в методите <code>get()</code> и <code>set()</code>? Какво би могло да се случи без нея?</p>
                    <div class="answer-section">
                        <button class="answer-btn">Покажи Отговор ↓</button>
                        <div class="answer-content">
                            <p><strong>Отговор:</strong> Проверката на границите е критична за безопасност и коректност.</p>
                            <p><strong>Без проверка могат да се случат:</strong></p>
                            <ul>
                                <li><strong>Buffer overflow:</strong> Писане извън масива, презаписване на друга памет</li>
                                <li><strong>Segmentation fault:</strong> Опит за достъп до невалидна памет → crash</li>
                                <li><strong>Undefined behavior:</strong> Непредсказуемо поведение на програмата</li>
                                <li><strong>Security vulnerabilities:</strong> Възможност за атаки</li>
                                <li><strong>Data corruption:</strong> Повреждане на други данни в паметта</li>
                            </ul>
                            <p><strong>С проверка:</strong></p>
                            <pre><code class="language-cpp">T get(size_t index) const {
    if (index >= capacity) {
        throw std::out_of_range("Индекс извън границите");
    }
    return data[index];
}</code></pre>
                        </div>
                    </div>
                </div>
            </div>

            <div class="exercise-card">
                <div class="exercise-header">
                    <div class="exercise-title-group">
                        <input type="checkbox" class="exercise-checkbox" id="ex15">
                        <label for="ex15" class="exercise-number">Упражнение 15</label>
                    </div>
                    <span class="difficulty-badge medium">СРЕДНО</span>
                </div>
                <div class="exercise-content">
                    <p><strong>Проследяване:</strong> Проследете двоично търсене за стойността 17 в сортирания масив <code>{3, 7, 11, 17, 23, 31, 39, 47}</code>. Покажете стойностите на <code>low</code>, <code>high</code> и <code>mid</code> на всяка стъпка.</p>
                    <div class="answer-section">
                        <button class="answer-btn">Покажи Отговор ↓</button>
                        <div class="answer-content">
                            <p><strong>Отговор:</strong></p>
                            <p><strong>Стъпка 1:</strong></p>
                            <ul>
                                <li>low = 0, high = 7</li>
                                <li>mid = 0 + (7-0)/2 = 3</li>
                                <li>arr[3] = 17 ← Намерен!</li>
                            </ul>
                            <p><strong>Резултат:</strong> Елементът е намерен веднага на индекс 3 след само 1 сравнение, защото 17 е точно в средата на масива.</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="exercise-card">
                <div class="exercise-header">
                    <div class="exercise-title-group">
                        <input type="checkbox" class="exercise-checkbox" id="ex16">
                        <label for="ex16" class="exercise-number">Упражнение 16</label>
                    </div>
                    <span class="difficulty-badge medium">СРЕДНО</span>
                </div>
                <div class="exercise-content">
                    <p><strong>Сравнение:</strong> Сравнете максималния брой сравнения, необходими за линейно търсене спрямо двоично търсене в масив от 1,024 елемента. Покажете изчисленията си.</p>
                    <div class="answer-section">
                        <button class="answer-btn">Покажи Отговор ↓</button>
                        <div class="answer-content">
                            <p><strong>Отговор:</strong></p>
                            <p><strong>Линейно търсене (O(n)):</strong></p>
                            <ul>
                                <li>Максимален брой сравнения = размер на масива</li>
                                <li>За 1024 елемента: <strong>1024 сравнения</strong></li>
                            </ul>
                            <p><strong>Двоично търсене (O(log n)):</strong></p>
                            <ul>
                                <li>Максимален брой сравнения = ⌈log₂(n)⌉</li>
                                <li>log₂(1024) = log₂(2¹⁰) = 10</li>
                                <li>За 1024 елемента: <strong>10 сравнения</strong></li>
                            </ul>
                            <p><strong>Заключение:</strong> Двоичното търсене е <strong>102 пъти по-бързо</strong> (1024 / 10 ≈ 102) за този размер масив!</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="exercise-card">
                <div class="exercise-header">
                    <div class="exercise-title-group">
                        <input type="checkbox" class="exercise-checkbox" id="ex17">
                        <label for="ex17" class="exercise-number">Упражнение 17</label>
                    </div>
                    <span class="difficulty-badge medium">СРЕДНО</span>
                </div>
                <div class="exercise-content">
                    <p><strong>Сигнатура на функция:</strong> Напишете C++ сигнатура на функция (само заглавието) за функция за двоично търсене, която търси целеви низ в сортиран вектор от низове. Включете подходящи const квалификатори и тип на връщане.</p>
                    <div class="answer-section">
                        <button class="answer-btn">Покажи Отговор ↓</button>
                        <div class="answer-content">
                            <p><strong>Отговор:</strong></p>
                            <pre><code class="language-cpp">int binarySearch(const std::vector<std::string>& arr, const std::string& target);</code></pre>
                            <p><strong>Обяснение на всяка част:</strong></p>
                            <ul>
                                <li><code>int</code> - връща индекс (или -1 ако не е намерен)</li>
                                <li><code>const std::vector&lt;std::string&gt;&</code> - const препратка (не копира, не модифицира)</li>
                                <li><code>const std::string&</code> - целевият низ също const препратка</li>
                            </ul>
                            <p>Алтернативен вариант с <code>size_t</code>:</p>
                            <pre><code class="language-cpp">std::optional<size_t> binarySearch(const std::vector<std::string>& arr, const std::string& target);</code></pre>
                        </div>
                    </div>
                </div>
            </div>

            <div class="exercise-card">
                <div class="exercise-header">
                    <div class="exercise-title-group">
                        <input type="checkbox" class="exercise-checkbox" id="ex18">
                        <label for="ex18" class="exercise-number">Упражнение 18</label>
                    </div>
                    <span class="difficulty-badge medium">СРЕДНО</span>
                </div>
                <div class="exercise-content">
                    <p><strong>Обяснение:</strong> Обяснете какво означава "дълбоко копиране" в контекста на конструктора за копиране за custom array клас. Защо е необходимо?</p>
                    <div class="answer-section">
                        <button class="answer-btn">Покажи Отговор ↓</button>
                        <div class="answer-content">
                            <p><strong>Отговор:</strong> Дълбокото копиране означава създаване на истинско, независимо копие на всички данни, не само копиране на указатели.</p>
                            <p><strong>Без дълбоко копиране (плитко копиране):</strong></p>
                            <ul>
                                <li>Двата обекта споделят същата памет</li>
                                <li>Промяна в единия засяга другия</li>
                                <li>Двойно освобождаване на паметта при унищожаване → crash</li>
                            </ul>
                            <p><strong>С дълбоко копиране:</strong></p>
                            <pre><code class="language-cpp">CustomArray(const CustomArray& other) : capacity(other.capacity) {
    data = new T[capacity];  // Нова памет
    for (size_t i = 0; i < capacity; ++i) {
        data[i] = other.data[i];  // Копиране на стойности
    }
}</code></pre>
                            <p>Всеки обект има своя собствена независима памет.</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="exercise-card">
                <div class="exercise-header">
                    <div class="exercise-title-group">
                        <input type="checkbox" class="exercise-checkbox" id="ex19">
                        <label for="ex19" class="exercise-number">Упражнение 19</label>
                    </div>
                    <span class="difficulty-badge medium">СРЕДНО</span>
                </div>
                <div class="exercise-content">
                    <p><strong>Въпрос:</strong> Каква е целта на деструктора в класа <code>CustomArray</code>? Какво би се случило, ако забравите да го имплементирате?</p>
                    <div class="answer-section">
                        <button class="answer-btn">Покажи Отговор ↓</button>
                        <div class="answer-content">
                            <p><strong>Отговор:</strong> Деструкторът освобождава динамично заделената памет когато обектът бива унищожен.</p>
                            <pre><code class="language-cpp">~CustomArray() {
    delete[] data;  // Освобождава паметта
    data = nullptr;
}</code></pre>
                            <p><strong>Без деструктор:</strong></p>
                            <ul>
                                <li><strong>Memory leak:</strong> Заделената памет никога не се освобождава</li>
                                <li>При много създавания/унищожавания паметта се изчерпва</li>
                                <li>Програмата може да стане бавна или да се срине</li>
                                <li>Особено проблематично в дългосрочни приложения</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

            <div class="exercise-card">
                <div class="exercise-header">
                    <div class="exercise-title-group">
                        <input type="checkbox" class="exercise-checkbox" id="ex20">
                        <label for="ex20" class="exercise-number">Упражнение 20</label>
                    </div>
                    <span class="difficulty-badge medium">СРЕДНО</span>
                </div>
                <div class="exercise-content">
                    <p><strong>Въпрос:</strong> При двоично търсене, защо <code>mid = low + (high - low) / 2</code> се предпочита пред <code>mid = (low + high) / 2</code>?</p>
                    <div class="answer-section">
                        <button class="answer-btn">Покажи Отговор ↓</button>
                        <div class="answer-content">
                            <p><strong>Отговор:</strong> За да се избегне <strong>integer overflow</strong>.</p>
                            <p><strong>Проблем с <code>(low + high) / 2</code>:</strong></p>
                            <ul>
                                <li>Ако low и high са много големи числа, low + high може да надхвърли максималната стойност на int</li>
                                <li>Например: low = 2,000,000,000 и high = 2,000,000,000</li>
                                <li>low + high = 4,000,000,000 > INT_MAX (обикновено 2,147,483,647)</li>
                                <li>Резултат: overflow → неправилна стойност</li>
                            </ul>
                            <p><strong>С <code>low + (high - low) / 2</code>:</strong></p>
                            <ul>
                                <li>Първо изчисляваме разликата: high - low</li>
                                <li>Делим я на 2</li>
                                <li>Добавяме към low</li>
                                <li>Никога не надхвърляме лимитите</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Hard Level -->
        <section id="hard" class="exercises-section">
            <h2>Трудно Ниво (21-30)</h2>

            <div class="exercise-card">
                <div class="exercise-header">
                    <div class="exercise-title-group">
                        <input type="checkbox" class="exercise-checkbox" id="ex21">
                        <label for="ex21" class="exercise-number">Упражнение 21</label>
                    </div>
                    <span class="difficulty-badge hard">ТРУДНО</span>
                </div>
                <div class="exercise-content">
                    <p><strong>Имплементация:</strong> Имплементирайте пълна C++ член-функция <code>void CustomArray::reverse()</code>, която обръща елементите в масива на място (без създаване на нов масив). Обмислете времева и пространствена сложност.</p>
                    <div class="answer-section">
                        <button class="answer-btn">Покажи Отговор ↓</button>
                        <div class="answer-content">
                            <pre><code class="language-cpp">template <typename T>
void CustomArray<T>::reverse() {
    size_t left = 0;
    size_t right = capacity - 1;
    
    // Разменяме елементи от двата края към центъра
    while (left < right) {
        // Swap data[left] и data[right]
        T temp = data[left];
        data[left] = data[right];
        data[right] = temp;
        
        left++;
        right--;
    }
}

// Алтернативно с std::swap:
template <typename T>
void CustomArray<T>::reverse() {
    for (size_t i = 0; i < capacity / 2; ++i) {
        std::swap(data[i], data[capacity - 1 - i]);
    }
}</code></pre>
                            <p><strong>Сложност:</strong></p>
                            <ul>
                                <li>Времева: O(n) - обхождаме половината от масива</li>
                                <li>Пространствена: O(1) - използваме само временна променлива</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

            <div class="exercise-card">
                <div class="exercise-header">
                    <div class="exercise-title-group">
                        <input type="checkbox" class="exercise-checkbox" id="ex22">
                        <label for="ex22" class="exercise-number">Упражнение 22</label>
                    </div>
                    <span class="difficulty-badge hard">ТРУДНО</span>
                </div>
                <div class="exercise-content">
                    <p><strong>Дизайн и Имплементация:</strong> Проектирайте и имплементирайте C++ функция, която използва двоично търсене за намиране на <strong>първото срещане</strong> на целева стойност в сортиран масив, който може да съдържа дубликати.</p>
                    <div class="answer-section">
                        <button class="answer-btn">Покажи Отговор ↓</button>
                        <div class="answer-content">
                            <pre><code class="language-cpp">int findFirstOccurrence(const std::vector<int>& arr, int target) {
    int low = 0;
    int high = arr.size() - 1;
    int result = -1;  // Запазваме резултата
    
    while (low <= high) {
        int mid = low + (high - low) / 2;
        
        if (arr[mid] == target) {
            result = mid;      // Запазваме позицията
            high = mid - 1;    // Продължаваме да търсим НАЛЯВО
        } else if (arr[mid] < target) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    
    return result;
}</code></pre>
                            <p><strong>Ключова идея:</strong> Когато намерим елемента, не спираме веднага, а продължаваме да търсим в лявата половина (<code>high = mid - 1</code>), за да намерим по-ранно срещане.</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="exercise-card">
                <div class="exercise-header">
                    <div class="exercise-title-group">
                        <input type="checkbox" class="exercise-checkbox" id="ex23">
                        <label for="ex23" class="exercise-number">Упражнение 23</label>
                    </div>
                    <span class="difficulty-badge hard">ТРУДНО</span>
                </div>
                <div class="exercise-content">
                    <p><strong>Анализ:</strong> Анализирайте времевата сложност на следната операция: Имате несортиран масив от n елемента и искате да търсите стойност използвайки двоично търсене. Включете времето, необходимо за сортиране на масива първо.</p>
                    <div class="answer-section">
                        <button class="answer-btn">Покажи Отговор ↓</button>
                        <div class="answer-content">
                            <p><strong>Отговор:</strong></p>
                            <p><strong>Обща сложност:</strong></p>
                            <ul>
                                <li>Сортиране: O(n log n) - например QuickSort или MergeSort</li>
                                <li>Двоично търсене: O(log n)</li>
                                <li><strong>Обща: O(n log n) + O(log n) = O(n log n)</strong></li>
                            </ul>
                            <p><strong>Сравнение с линейно търсене:</strong></p>
                            <ul>
                                <li>Линейно търсене: O(n)</li>
                                <li>С сортиране + двоично: O(n log n)</li>
                            </ul>
                            <p><strong>Кога си струва:</strong></p>
                            <ul>
                                <li><strong>За едно търсене:</strong> НЕ си струва (O(n log n) > O(n))</li>
                                <li><strong>За k търсения:</strong> O(n log n) + k×O(log n) vs k×O(n)</li>
                                <li>Изгодно когато k > log n (приблизително)</li>
                                <li>Например: 1000 елемента, >10 търсения → си струва да сортираме</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

            <div class="exercise-card">
                <div class="exercise-header">
                    <div class="exercise-title-group">
                        <input type="checkbox" class="exercise-checkbox" id="ex24">
                        <label for="ex24" class="exercise-number">Упражнение 24</label>
                    </div>
                    <span class="difficulty-badge hard">ТРУДНО</span>
                </div>
                <div class="exercise-content">
                    <p><strong>Template Клас:</strong> Напишете C++ template клас <code>ResizableArray&lt;T&gt;</code>, който разширява концепцията на <code>CustomArray</code> чрез добавяне на метод <code>resize(size_t newCapacity)</code>.</p>
                    <div class="answer-section">
                        <button class="answer-btn">Покажи Отговор ↓</button>
                        <div class="answer-content">
                            <pre><code class="language-cpp">template <typename T>
class ResizableArray {
private:
    T* data;
    size_t capacity;
    size_t size;  // Брой използвани елементи
    
public:
    ResizableArray(size_t cap = 10) 
        : capacity(cap), size(0) {
        data = new T[capacity];
    }
    
    ~ResizableArray() {
        delete[] data;
    }
    
    void resize(size_t newCapacity) {
        if (newCapacity == capacity) return;
        
        // Заделяме нова памет
        T* newData = new T[newCapacity];
        
        // Копираме колкото се побират елементи
        size_t elementsToCopy = (newCapacity < size) ? newCapacity : size;
        for (size_t i = 0; i < elementsToCopy; ++i) {
            newData[i] = data[i];
        }
        
        // Освобождаваме старата памет
        delete[] data;
        
        // Актуализираме указателя и капацитета
        data = newData;
        capacity = newCapacity;
        
        // Ако сме смалили, актуализираме size
        if (size > newCapacity) {
            size = newCapacity;
        }
    }
    
    // Останали методи...
};</code></pre>
                        </div>
                    </div>
                </div>
            </div>

            <div class="exercise-card">
                <div class="exercise-header">
                    <div class="exercise-title-group">
                        <input type="checkbox" class="exercise-checkbox" id="ex25">
                        <label for="ex25" class="exercise-number">Упражнение 25</label>
                    </div>
                    <span class="difficulty-badge hard">ТРУДНО</span>
                </div>
                <div class="exercise-content">
                    <p><strong>Модифицирано Търсене:</strong> Имплементирайте модифицирана функция за двоично търсене, която намира позицията за вмъкване на целева стойност в сортиран масив.</p>
                    <div class="answer-section">
                        <button class="answer-btn">Покажи Отговор ↓</button>
                        <div class="answer-content">
                            <pre><code class="language-cpp">size_t findInsertPosition(const std::vector<int>& arr, int target) {
    size_t low = 0;
    size_t high = arr.size();  // Забележка: size(), не size()-1
    
    // Търсим най-лявата позиция, където target <= arr[pos]
    while (low < high) {
        size_t mid = low + (high - low) / 2;
        
        if (arr[mid] < target) {
            low = mid + 1;  // Целта е вдясно
        } else {
            high = mid;     // Целта е вляво или на mid
        }
    }
    
    return low;  // low е правилната позиция за вмъкване
}

// Пример: arr = {1, 3, 5, 7, 9}, target = 6
// Резултат: 3 (между 5 и 7)</code></pre>
                            <p><strong>Забележки:</strong> Тази техника се нарича "lower_bound" и е имплементирана в <code>std::lower_bound</code>.</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="exercise-card">
                <div class="exercise-header">
                    <div class="exercise-title-group">
                        <input type="checkbox" class="exercise-checkbox" id="ex26">
                        <label for="ex26" class="exercise-number">Упражнение 26</label>
                    </div>
                    <span class="difficulty-badge hard">ТРУДНО</span>
                </div>
                <div class="exercise-content">
                    <p><strong>Сценарий и Анализ:</strong> Разгледайте сценарий, при който трябва често да вмъквате елементи в сортиран масив, като поддържате сортирания ред.</p>
                    <div class="answer-section">
                        <button class="answer-btn">Покажи Отговор ↓</button>
                        <div class="answer-content">
                            <p><strong>Отговор:</strong></p>
                            <p><strong>Анализ за n вмъквания:</strong></p>
                            <ul>
                                <li>Двоично търсене за позиция: O(log n)</li>
                                <li>Местене на елементи за вмъкване: O(n) в най-лош случай</li>
                                <li>Обща сложност за едно вмъкване: <strong>O(n)</strong></li>
                                <li>За n вмъквания: <strong>O(n²)</strong></li>
                            </ul>
                            <p><strong>Двоичното търсене помага ли?</strong></p>
                            <ul>
                                <li>Да, за намиране на позицията (O(log n))</li>
                                <li>НО местенето на елементи остава O(n)</li>
                                <li>Общата сложност е доминирана от местенето</li>
                            </ul>
                            <p><strong>По-добри алтернативи:</strong></p>
                            <ul>
                                <li><strong>Балансирано двоично дърво (AVL, Red-Black):</strong> O(log n) за insert/delete/search</li>
                                <li><strong>Skip List:</strong> O(log n) вероятностна сложност</li>
                                <li><strong>B-Tree:</strong> Оптимизирано за дисков достъп</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

            <div class="exercise-card">
                <div class="exercise-header">
                    <div class="exercise-title-group">
                        <input type="checkbox" class="exercise-checkbox" id="ex27">
                        <label for="ex27" class="exercise-number">Упражнение 27</label>
                    </div>
                    <span class="difficulty-badge hard">ТРУДНО</span>
                </div>
                <div class="exercise-content">
                    <p><strong>Отстраняване на Грешки:</strong> Отстранете и поправете тази бъгната имплементация на двоично търсене:</p>
                    <pre><code class="language-cpp">int binarySearch(const vector&lt;int&gt;& arr, int target) {
    int low = 0;
    int high = arr.size();
    while (low < high) {
        int mid = (low + high) / 2;
        if (arr[mid] == target) return mid;
        if (arr[mid] < target) low = mid;
        else high = mid;
    }
    return -1;
}</code></pre>
                    <div class="answer-section">
                        <button class="answer-btn">Покажи Отговор ↓</button>
                        <div class="answer-content">
                            <p><strong>Грешки и корекции:</strong></p>
                            <p><strong>1. Грешка:</strong> <code>int high = arr.size();</code></p>
                            <ul>
                                <li><strong>Проблем:</strong> high трябва да е последният валиден индекс</li>
                                <li><strong>Корекция:</strong> <code>int high = arr.size() - 1;</code></li>
                            </ul>
                            <p><strong>2. Грешка:</strong> <code>while (low < high)</code></p>
                            <ul>
                                <li><strong>Проблем:</strong> Пропуска случая когато low == high</li>
                                <li><strong>Корекция:</strong> <code>while (low <= high)</code></li>
                            </ul>
                            <p><strong>3. Грешка:</strong> <code>low = mid;</code></p>
                            <ul>
                                <li><strong>Проблем:</strong> Безкраен цикъл! Не напредваме</li>
                                <li><strong>Корекция:</strong> <code>low = mid + 1;</code></li>
                            </ul>
                            <p><strong>4. Грешка:</strong> <code>high = mid;</code></p>
                            <ul>
                                <li><strong>Проблем:</strong> Безкраен цикъл!</li>
                                <li><strong>Корекция:</strong> <code>high = mid - 1;</code></li>
                            </ul>
                            <p><strong>5. Потенциална грешка:</strong> <code>(low + high) / 2</code></p>
                            <ul>
                                <li><strong>Проблем:</strong> Integer overflow за големи стойности</li>
                                <li><strong>Корекция:</strong> <code>low + (high - low) / 2</code></li>
                            </ul>
                            <p><strong>Коректна версия:</strong></p>
                            <pre><code class="language-cpp">int binarySearch(const vector<int>& arr, int target) {
    int low = 0;
    int high = arr.size() - 1;  // Корекция 1
    while (low <= high) {        // Корекция 2
        int mid = low + (high - low) / 2;  // Корекция 5
        if (arr[mid] == target) return mid;
        if (arr[mid] < target) low = mid + 1;   // Корекция 3
        else high = mid - 1;                     // Корекция 4
    }
    return -1;
}</code></pre>
                        </div>
                    </div>
                </div>
            </div>

            <div class="exercise-card">
                <div class="exercise-header">
                    <div class="exercise-title-group">
                        <input type="checkbox" class="exercise-checkbox" id="ex28">
                        <label for="ex28" class="exercise-number">Упражнение 28</label>
                    </div>
                    <span class="difficulty-badge hard">ТРУДНО</span>
                </div>
                <div class="exercise-content">
                    <p><strong>Exception Safety:</strong> Имплементирайте <code>operator=</code> (оператор за присвояване) за класа <code>CustomArray</code> с пълна безопасност при изключения.</p>
                    <div class="answer-section">
                        <button class="answer-btn">Покажи Отговор ↓</button>
                        <div class="answer-content">
                            <pre><code class="language-cpp">template <typename T>
CustomArray<T>& CustomArray<T>::operator=(const CustomArray& other) {
    // Проверка за самоприсвояване
    if (this == &other) {
        return *this;
    }
    
    // Copy-and-swap idiom за exception safety
    // Заделяме НОВА памет преди да променим текущия обект
    T* newData = new T[other.capacity];  // Може да хвърли bad_alloc
    
    // Ако new успее, копираме данните
    for (size_t i = 0; i < other.capacity; ++i) {
        newData[i] = other.data[i];
    }
    
    // Сега сме сигурни, че всичко е наред
    // Освобождаваме старата памет
    delete[] data;
    
    // Актуализираме this
    data = newData;
    capacity = other.capacity;
    
    return *this;
}

// Алтернативно - copy-and-swap idiom:
template <typename T>
CustomArray<T>& CustomArray<T>::operator=(CustomArray other) {  // Copy по стойност
    std::swap(data, other.data);
    std::swap(capacity, other.capacity);
    return *this;  // other се унищожава и освобождава старата памет
}</code></pre>
                            <p><strong>Strong exception guarantee:</strong> Ако new хвърли изключение, оригиналният обект остава непроменен.</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="exercise-card">
                <div class="exercise-header">
                    <div class="exercise-title-group">
                        <input type="checkbox" class="exercise-checkbox" id="ex29">
                        <label for="ex29" class="exercise-number">Упражнение 29</label>
                    </div>
                    <span class="difficulty-badge hard">ТРУДНО</span>
                </div>
                <div class="exercise-content">
                    <p><strong>Дизайн на Клас:</strong> Проектирайте C++ клас <code>SortedArray</code>, който поддържа елементите в сортиран ред автоматично.</p>
                    <div class="answer-section">
                        <button class="answer-btn">Покажи Отговор ↓</button>
                        <div class="answer-content">
                            <pre><code class="language-cpp">template <typename T>
class SortedArray {
private:
    std::vector<T> data;
    
public:
    // Вмъкване - O(n)
    void insert(const T& value) {
        // Намираме позиция за вмъкване - O(log n)
        auto pos = std::lower_bound(data.begin(), data.end(), value);
        data.insert(pos, value);  // Вмъкване - O(n)
    }
    
    // Търсене - O(log n)
    bool search(const T& value) const {
        return std::binary_search(data.begin(), data.end(), value);
    }
    
    // Намиране на индекс - O(log n)
    int find(const T& value) const {
        auto it = std::lower_bound(data.begin(), data.end(), value);
        if (it != data.end() && *it == value) {
            return std::distance(data.begin(), it);
        }
        return -1;
    }
    
    // Изтриване - O(n)
    bool remove(const T& value) {
        auto it = std::lower_bound(data.begin(), data.end(), value);
        if (it != data.end() && *it == value) {
            data.erase(it);  // O(n) - мести елементи
            return true;
        }
        return false;
    }
    
    T get(size_t index) const { return data[index]; }
    size_t size() const { return data.size(); }
};</code></pre>
                            <p><strong>Компромиси спрямо несортиран масив:</strong></p>
                            <table>
                                <tr>
                                    <th>Операция</th>
                                    <th>SortedArray</th>
                                    <th>Несортиран</th>
                                </tr>
                                <tr>
                                    <td>Търсене</td>
                                    <td>O(log n) ✅</td>
                                    <td>O(n)</td>
                                </tr>
                                <tr>
                                    <td>Вмъкване</td>
                                    <td>O(n) ⚠️</td>
                                    <td>O(1) в края</td>
                                </tr>
                                <tr>
                                    <td>Изтриване</td>
                                    <td>O(n) ⚠️</td>
                                    <td>O(n)</td>
                                </tr>
                                <tr>
                                    <td>Достъп</td>
                                    <td>O(1) ✅</td>
                                    <td>O(1) ✅</td>
                                </tr>
                            </table>
                        </div>
                    </div>
                </div>
            </div>

            <div class="exercise-card">
                <div class="exercise-header">
                    <div class="exercise-title-group">
                        <input type="checkbox" class="exercise-checkbox" id="ex30">
                        <label for="ex30" class="exercise-number">Упражнение 30</label>
                    </div>
                    <span class="difficulty-badge hard">ТРУДНО</span>
                </div>
                <div class="exercise-content">
                    <p><strong>Есе:</strong> Напишете цялостно сравнение (поне 300 думи), обсъждащо кога да използвате масиви спрямо други структури от данни.</p>
                    <div class="answer-section">
                        <button class="answer-btn">Покажи Отговор ↓</button>
                        <div class="answer-content">
                            <p><strong>Сравнение на Структури от Данни за Реални Приложения</strong></p>
                            
                            <p><strong>1. Системи в Реално Време (Real-Time Systems)</strong></p>
                            <p>В критични за времето системи като управление на самолети, автомобили или медицинско оборудване, <strong>статичните масиви</strong> са предпочитани. Тяхното константно време за достъп O(1) и предсказуемо използване на памет са критични. Динамичното заделяне (new/malloc) е често забранено поради непредсказуемото време за изпълнение и риск от фрагментация. std::vector може да предизвика неочаквани забавяния при преоразмеряване.</p>
                            
                            <p><strong>2. Индексиране на Бази Данни</strong></p>
                            <p>За индексиране се използват специализирани структури като <strong>B-Tree и B+ Tree</strong> вместо прости масиви. Причините са: (1) Базите данни са динамични - чести INSERT/DELETE операции; (2) Масивите изискват O(n) за вмъкване/изтриване; (3) B-Trees поддържат баланс автоматично с O(log n) за всички операции; (4) Оптимизирани за дисков I/O с големи възли. Масиви се използват само за малки, статични lookup таблици.</p>
                            
                            <p><strong>3. Текстови Редактори</strong></p>
                            <p>Модерни редактори като VS Code използват сложни структури - не прости масиви. <strong>Rope data structure</strong> или <strong>Gap Buffer</strong> са предпочитани защото: (1) Текстът се променя често - INSERT/DELETE операции; (2) Масивите изискват O(n) за вмъкване на символ в средата; (3) Rope позволява O(log n) операции чрез дървовидна структура; (4) Gap buffer оптимизира cursor movement. За малки текстове (< 1000 символа) std::vector е достатъчен.</p>
                            
                            <p><strong>4. Социални Медии Фийдове</strong></p>
                            <p>За фийдове (Facebook, Twitter) се използват <strong>комбинация от структури</strong>: (1) std::vector или std::deque за текущо видимите постове в паметта; (2) Hash tables (std::unordered_map) за бърз lookup на потребители/постове по ID; (3) Приоритетни опашки за ranking алгоритми; (4) Linked lists понякога за historical scrolling. Прости масиви са неподходящи поради: променлив размер, чести актуализации, нужда от бързо търсене по ключ (не по индекс).</p>
                            
                            <p><strong>Общи Фактори за Решение:</strong></p>
                            <ul>
                                <li><strong>Шаблони на достъп:</strong> Произволен → масиви; Секвенциален → списъци</li>
                                <li><strong>Честота на модификация:</strong> Редки → масиви; Чести → дървета/хеш таблици</li>
                                <li><strong>Ограничения на паметта:</strong> Строги → масиви; Гъвкави → динамични структури</li>
                                <li><strong>Изисквания за производителност:</strong> O(1) достъп → масиви; O(log n) баланс → дървета</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Clear Progress Button -->
        <div class="clear-progress-container">
            <button id="clear-progress" class="clear-btn">Изчисти Прогреса (Ctrl+Shift+C)</button>
        </div>
    </main>

    <!-- Footer -->
    <footer>
        <p>&copy; 2025 ФМИ - Структури от Данни и Програмиране. Всички права запазени.</p>
        <p class="footer-note">Напредъкът се запазва автоматично в браузъра</p>
    </footer>

    <script src="exercises-script.js"></script>
</body>
</html>
